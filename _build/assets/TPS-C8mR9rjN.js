import{c as z,j as se,g as ae,t as re,b as ne,s as g,i as oe,k as fe,l as T,n as J,u as N}from"./client-CA75qaa4.js";const he={path:[468,473],closed:!1,name:"Eye line",description:"Draw a line from left to right that connects the centers of the eyes."},ce={path:[98,327],closed:!1,name:"Nose line",description:"Draw a line from left to right that connects the outer edge of each nostril."},ue={path:[78,308],closed:!1,name:"Mouth line",description:"Draw a line from left to right that connects the left edge of the mouth to the right edge of the mouth."},le={path:[148,377],closed:!1,name:"Chin line",description:"Draw a line from left to right that represents the bottom of the chin."},de={path:[118,347],closed:!1,name:"Cheekbone line",description:"Draw a line from left to right that connects the tops of the cheekbones."},me={path:[105,334],closed:!1,name:"Brow line",description:"Draw a line from left to right that connects the centers of the eyebrows."},ge={path:[83,313],closed:!1,name:"Upper chin",description:"Draw a line from left to right that represents the top of the chin under the lips."},pe={path:[37,267],closed:!1,name:"Upper lip",description:"Draw a line from left to right that connects the peaks of the upper lip."},ve={path:[10,168],closed:!1,name:"Top symmetry",description:"Draw a line from the top center of the forehead to the bridge of the nose."},Pe={path:[226,446],closed:!1,name:"Outer corners of eyes",description:"Draw a line from left to right that connects the outer corners of the eyes."},be={path:[173,398],closed:!1,name:"Inner corners of eyes",description:"Draw a line from left to right that connects the inner corners (tear ducts) of the eyes."},Be={path:[470,472],closed:!1,name:"Left eye bisect",description:"Draw a line from top to bottom that bisects the left eye."},ye={path:[475,477],closed:!1,name:"Right eye bisect",description:"Draw a line from top to bottom that bisects the right eye."},we={path:[67,297],closed:!1,name:"Forehead line",description:"Draw a line from left to right that connects the middle of the forehead above the eyebrows."},xe={path:[172,397],closed:!1,name:"Jaw line",description:"Draw a line from left to right that represents the bottom of the jaw at the outside of the face."},F={path:[10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109],closed:!0,name:"Silhouette",description:"Starting at the top of the forehead and going clockwise, outline the face."},w={pupilLine:he,noseLine:ce,mouthLine:ue,chinLine:le,cheekboneLine:de,browLine:me,upperChin:ge,upperLip:pe,topBridge:ve,outerEyes:Pe,innerEyes:be,leftEyeBisection:Be,rightEyeBisection:ye,foreheadLine:we,jawLine:xe,silhouette:F};var Ce=re('<div id=pareidolia style=flex-direction:row;align-items:center;justify-content:center><div style="flex-direction:column;align-items:center;justify-content:center;transform-origin:center center;flex-grow:3;flex-shrink:0"><div style=font-size:16px;pointer-events:none;z-index:1000>Drop an image here</div><canvas id=source></canvas><svg id=landmarks xmlns=http://www.w3.org/2000/svg style=stroke:blue;fill:rgba(255,255,255,0.4)></svg></div><!$><!/>');const X=0,Ye=f=>{let e,t,i,a;const[s,n]=z(!1),[r,u]=z({width:600,height:600}),[m,C]=z(1),[k,I]=z("Upload an Image"),v={};let y=0,Y,M=null;const A=h=>{const o=r().width,c=r().height,d=h.filter((_,G)=>G%3===0),P=h.filter((_,G)=>G%3===1),S=Math.min(...d),x=Math.min(...P),l=Math.max(...d),b=Math.max(...P),B=(o-2*X)/(l-S),U=(c-2*X)/(b-x);return h.map((_,G)=>G%3===0?(_-S)*B+X:G%3===1?c-((_-x)*U+X):_)};A(J.vertices);const O=(h,o)=>{const d=window.innerHeight*.8;return Math.min(d/o,1)};let D=()=>{};const E=()=>{D();const h=Object.keys(w)[y];I(h)},ee=async()=>{D(),M&&(f.tpsConfig.destroy(M),M=null);const h=new Map;for(const o in v)if(!(w[o].path.length==0||v[o].length==0))if(w[o].path.length==1)h.set(w[o].path[0],[v[o][0].x,v[o][0].y,0]);else if(w[o].path.length==2)h.set(w[o].path[0],[v[o][0].x,v[o][0].y,0]),h.set(w[o].path[1],[v[o][1].x,v[o][1].y,0]);else for(let c=0;c<w[o].path.length;c++)v[o][c]&&h.set(w[o].path[c],[v[o][c].x,v[o][c].y,0]);M=f.tpsConfig.create(h,Y),f.onImageProcessed&&f.onImageProcessed(Y)},te=h=>{h.preventDefault(),h.stopPropagation()},ie=h=>{h.preventDefault(),h.stopPropagation();const o=h.dataTransfer?.files;if(!o||o.length===0)return;const c=o[0];if(!c.type.startsWith("image/")){alert("Please drop an image file");return}const d=new FileReader;d.onload=P=>{const S=new Image;S.onload=()=>{const l=Math.min(1,640/S.width,640/S.height),b=S.width*l,B=S.height*l;u({width:b,height:B});const U=O(b,B);C(U),e&&(e.width=b,e.height=B,t=e.getContext("2d"),t?.drawImage(S,0,0,b,B)),i&&(i.setAttribute("width",b.toString()),i.setAttribute("height",B.toString())),Y=t?.getImageData(0,0,b,B),n(!0),A(J.vertices),E()},S.src=P.target?.result},d.readAsDataURL(c)};return se(()=>{if(!e||!i||(t=e.getContext("2d"),!s()))return;let h=!1,o={x:0,y:0};const c=document.createElementNS("http://www.w3.org/2000/svg","circle");c.setAttribute("cx",o.x.toString()),c.setAttribute("cy",o.y.toString()),c.setAttribute("r",(5/m()).toString()),c.style.stroke="red",c.style.fill="red";const d=document.createElementNS("http://www.w3.org/2000/svg","line");d.setAttribute("x1",o.x.toString()),d.setAttribute("y1",o.y.toString()),d.setAttribute("x2",o.x.toString()),d.setAttribute("y2",o.y.toString()),d.style.stroke="red",d.style.fill="red";const P=document.createElementNS("http://www.w3.org/2000/svg","path");P.setAttribute("d",`M ${o.x} ${o.y} L ${o.x} ${o.y}`),P.style.stroke="red",P.style.fill="rgba(255,0,0,0.2)";const S=x=>{const l=i.getBoundingClientRect(),b=(x.clientX-l.left)/m(),B=(x.clientY-l.top)/m();return{x:b,y:B}};D=()=>{c.remove(),d.remove(),P.remove()},i.onmousedown=x=>{if(y==null)return;const l=Object.keys(w)[y];x.preventDefault(),x.stopPropagation();const{x:b,y:B}=S(x);h=!0,o={x:b,y:B},v[l]=[],w[l].path.length==1?(c.setAttribute("cx",b.toString()),c.setAttribute("cy",B.toString()),i.appendChild(c)):w[l].path.length==2?(v[l].push(o),d.setAttribute("x1",o.x.toString()),d.setAttribute("y1",o.y.toString()),d.setAttribute("x2",o.x.toString()),d.setAttribute("y2",o.y.toString()),i.appendChild(d)):(v[l].push(o),P.setAttribute("d","M "+v[l].map((U,p)=>`${U.x} ${U.y}`).join(" L ")),i.appendChild(P))},i.onmousemove=x=>{if(y==null)return;const l=Object.keys(w)[y];if(x.preventDefault(),x.stopPropagation(),h){const{x:b,y:B}=S(x);w[l].path.length==1?(c.setAttribute("cx",b.toString()),c.setAttribute("cy",B.toString())):w[l].path.length==2?(d.setAttribute("x2",b.toString()),d.setAttribute("y2",B.toString())):(v[l].push({x:b,y:B}),P.setAttribute("d","M "+v[l].map((U,p)=>`${U.x} ${U.y}`).join(" L ")))}},i.onmouseup=x=>{if(y==null)return;const l=Object.keys(w)[y];x.preventDefault(),x.stopPropagation(),h=!1;const{x:b,y:B}=S(x);w[l].path.length==1?v[l].push(o):w[l].path.length==2?v[l].push({x:b,y:B}):(v[l].push({x:b,y:B}),v[l].push({x:o.x,y:o.y}),P.setAttribute("d","M "+v[l].map((U,p)=>`${U.x} ${U.y}`).join(" L "))),f.onFeatureComplete&&f.onFeatureComplete(l,v[l]),y++,y=Math.min(y,Object.keys(w).length),E(),D()}}),(()=>{var h=ae(Ce),o=h.firstChild,c=o.firstChild,d=c.nextSibling,P=d.nextSibling,S=o.nextSibling,[x,l]=ne(S.nextSibling);h.addEventListener("drop",ie),h.addEventListener("dragover",te);var b=a;typeof b=="function"?N(b,h):a=h,g(h,"position","relative"),g(h,"display","flex"),g(h,"border","2px dashed #ccc"),g(h,"padding","10px"),g(h,"width","100vw"),g(h,"height","100vh"),g(h,"background","rgba(255,0,0,.1)"),g(o,"position","relative"),g(o,"display","flex"),g(c,"position","absolute"),g(c,"top","50%"),g(c,"left","50%"),g(c,"transform","translate(-50%, -50%)"),g(c,"color","#999"),g(c,"background","white");var B=e;typeof B=="function"?N(B,d):e=d,g(d,"display","block");var U=i;return typeof U=="function"?N(U,P):i=P,g(P,"position","absolute"),g(P,"top","50%"),g(P,"left","50%"),g(P,"transform","translate(-50%, -50%)"),g(P,"filter","invert(1)"),oe(h,()=>f.controls.render({featureName:k(),currentFeature:y,onBack:()=>{y=Math.max(0,y-1),E()},onSkip:()=>{v[k()]=[],y++,y>=Object.keys(w).length&&(y=0),E()},onNext:()=>{y++,y>=Object.keys(w).length&&(y=0),E()},onProcess:()=>{ee()}}),x,l),fe(p=>{var _=`scale(${m()})`,G=s()?r().width*m()+"px":"auto",R=s()?r().height*m()+"px":"auto",L=s()?"none":"block",W=r().width,H=r().height,q=s()?`${-.5/m()}em ${.5/m()}em 0 rgba(0,0,0,.5), ${-1/m()}em ${1/m()}em 0 gray`:"none",j=r().width,$=r().height,V=s()?"auto":"none",Z=`${5/m()}px`;return _!==p.e&&g(o,"transform",p.e=_),G!==p.t&&g(o,"width",p.t=G),R!==p.a&&g(o,"height",p.a=R),L!==p.o&&g(c,"display",p.o=L),W!==p.i&&T(d,"width",p.i=W),H!==p.n&&T(d,"height",p.n=H),q!==p.s&&g(d,"box-shadow",p.s=q),j!==p.h&&T(P,"width",p.h=j),$!==p.r&&T(P,"height",p.r=$),V!==p.d&&g(P,"pointer-events",p.d=V),Z!==p.l&&g(P,"stroke-width",p.l=Z),p},{e:void 0,t:void 0,a:void 0,o:void 0,i:void 0,n:void 0,s:void 0,h:void 0,r:void 0,d:void 0,l:void 0}),h})()};class Se{device;context;canvas;commandEncoder;computePassEncoder;initialized;uniformBuffer;meshPointsBuffer;imagePointsBuffer;distortPointsBuffer;modelPointsBuffer;baseCoeffsBuffer;model2distortCoeffsBuffer;imageDataBuffer;faceDataBuffer;debugBuffer;bindGroup;bindGroupLayout;pipelineLayout;computePipeline;constructor(){this.device=null,this.context=null,this.canvas=null,this.commandEncoder=null,this.computePassEncoder=null,this.initialized=!1,this.uniformBuffer=null,this.meshPointsBuffer=null,this.imagePointsBuffer=null,this.distortPointsBuffer=null,this.modelPointsBuffer=null,this.baseCoeffsBuffer=null,this.model2distortCoeffsBuffer=null,this.imageDataBuffer=null,this.faceDataBuffer=null,this.debugBuffer=null,this.bindGroup=null,this.bindGroupLayout=null,this.pipelineLayout=null,this.computePipeline=null}async initialize(){try{if(!navigator.gpu)return console.error("WebGPU not supported"),!1;const e=await navigator.gpu.requestAdapter();return e?(this.device=await e.requestDevice({requiredLimits:{maxStorageBuffersPerShaderStage:10}}),this.canvas=document.createElement("canvas"),this.canvas.style.display="none",document.body.appendChild(this.canvas),this.context=this.canvas.getContext("webgpu"),this.context?(await this.setupComputeShader(),this.initialized=!0,!0):(console.error("WebGPU context not available"),!1)):(console.error("No WebGPU adapter found"),!1)}catch(e){return console.error("Failed to initialize WebGPU:",e),!1}}async setupComputeShader(){if(!this.device)throw new Error("Device not initialized");this.bindGroupLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:6,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:7,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:8,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),this.pipelineLayout=this.device.createPipelineLayout({bindGroupLayouts:[this.bindGroupLayout]});const e=`
      struct Uniforms {
        baseNumPoints: u32,
        distortNumPoints: u32,
        imageWidth: u32,
        imageHeight: u32,
        faceMinY: u32,
        faceMinX: u32,
        faceWidth: u32,
        faceHeight: u32,
      }

      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      @group(0) @binding(1) var<storage, read> meshPoints: array<f32>;
      @group(0) @binding(2) var<storage, read> imagePoints: array<f32>;
      @group(0) @binding(3) var<storage, read> distortPoints: array<f32>;
      @group(0) @binding(4) var<storage, read> modelPoints: array<f32>;
      @group(0) @binding(5) var<storage, read> baseCoeffs: array<f32>;
      @group(0) @binding(6) var<storage, read> model2distortCoeffs: array<f32>;
      @group(0) @binding(7) var<storage, read> imageData: array<u32>;
      @group(0) @binding(8) var<storage, read_write> faceData: array<u32>;

      // Radial basis function - r^2 * log(r) using built-in length function
      fn kernelFunction(dx: f32, dy: f32) -> f32 {
        if (dx == 0.0 && dy == 0.0) {
          return 0.0;
        }
        let dist = length(vec2<f32>(dx, dy));
        return dist * dist * log(dist * dist);
      }

      // Transform XY function with vec2 optimizations
      fn transformXY(point: vec2<f32>) -> vec2<f32> {
        let baseNumPoints = uniforms.baseNumPoints;
        let coeffsOffset = baseNumPoints + 3u;
        
        // Validate coefficient array bounds
        if (baseNumPoints == 0u || coeffsOffset * 4u > arrayLength(&baseCoeffs)) {
          return point; // Return original point if coefficients are invalid
        }
        
        // Step 1: baseTPS.inverse(point) - use inverse coefficients (offset 0)
        var baseInverse = vec2<f32>(0.0, 0.0);
        {
          var Xo = baseCoeffs[0] + baseCoeffs[1] * point.x + baseCoeffs[2] * point.y;
          var Yo = baseCoeffs[coeffsOffset] + baseCoeffs[coeffsOffset + 1] * point.x + baseCoeffs[coeffsOffset + 2] * point.y;
          
          for (var r = 0u; r < baseNumPoints; r++) {
            let sourcePoint = vec2<f32>(imagePoints[r * 2u], imagePoints[r * 2u + 1u]);
            let diff = point - sourcePoint;
            let tmp = kernelFunction(diff.x, diff.y);
            Xo += baseCoeffs[r + 3u] * tmp;
            Yo += baseCoeffs[coeffsOffset + r + 3u] * tmp;
          }
          baseInverse = vec2<f32>(Xo, Yo);
        }
        
        // Step 2: activeTPS.inverse(baseInverse) - use forward coefficients with swapped points
        var activeInverse = vec2<f32>(0.0, 0.0);
        {
          let distortNumPoints = uniforms.distortNumPoints;
          let distortCoeffsOffset = distortNumPoints + 3u;
          
          // Validate model2distort coefficients
          if (distortNumPoints == 0u || distortCoeffsOffset * 2u > arrayLength(&model2distortCoeffs)) {
            return baseInverse; // Return base inverse if coefficients are invalid
          }
          
          // For inverse transformation, we need to find the input that produces baseInverse as output
          // Since we have inverse coefficients, we can use them directly
          var Xo = model2distortCoeffs[0] + model2distortCoeffs[1] * baseInverse.x + model2distortCoeffs[2] * baseInverse.y;
          var Yo = model2distortCoeffs[distortCoeffsOffset] + model2distortCoeffs[distortCoeffsOffset + 1] * baseInverse.x + model2distortCoeffs[distortCoeffsOffset + 2] * baseInverse.y;
          
          for (var r = 0u; r < distortNumPoints; r++) {
            // For inverse transformation, use distortPoints as source (since we want to map back to model)
            let sourcePoint = vec2<f32>(distortPoints[r * 2u], distortPoints[r * 2u + 1u]);
            let diff = baseInverse - sourcePoint;
            let tmp = kernelFunction(diff.x, diff.y);
            Xo += model2distortCoeffs[r + 3u] * tmp;
            Yo += model2distortCoeffs[distortCoeffsOffset + r + 3u] * tmp;
          }
          activeInverse = vec2<f32>(Xo, Yo);
        }
        
        // Step 3: baseTPS.forward(activeInverse) - use forward coefficients (offset 2*coeffsOffset)
        var result = vec2<f32>(0.0, 0.0);
        {
          var Xo = baseCoeffs[coeffsOffset * 2u] + baseCoeffs[coeffsOffset * 2u + 1u] * activeInverse.x + baseCoeffs[coeffsOffset * 2u + 2u] * activeInverse.y;
          var Yo = baseCoeffs[coeffsOffset * 3u] + baseCoeffs[coeffsOffset * 3u + 1u] * activeInverse.x + baseCoeffs[coeffsOffset * 3u + 2u] * activeInverse.y;
          
          for (var r = 0u; r < baseNumPoints; r++) {
            let sourcePoint = vec2<f32>(meshPoints[r * 2u], meshPoints[r * 2u + 1u]);
            let diff = activeInverse - sourcePoint;
            let tmp = kernelFunction(diff.x, diff.y);
            Xo += baseCoeffs[coeffsOffset * 2u + r + 3u] * tmp;
            Yo += baseCoeffs[coeffsOffset * 3u + r + 3u] * tmp;
          }
          result = vec2<f32>(Xo, Yo);
        }
        
        return result;
      }

      // Sample image data with bounds checking - use optimized unpacking
      fn sampleImage(x: i32, y: i32) -> vec4<f32> {
        // if (x < 0 || x >= i32(uniforms.imageWidth) || y < 0 || y >= i32(uniforms.imageHeight)) {
        //   return vec4<f32>(0.0, 0.0, 0.0, 0.0);
        // }
        
        let index = (u32(y) % uniforms.imageHeight) * uniforms.imageWidth + (u32(x) % uniforms.imageWidth);
        let pixelData = imageData[index];
        
        // Use the optimized unpacking function
        return unpackRGBA(pixelData);
      }

      // Optimized RGBA packing using vector operations - ARGB format to match unpacking
      fn packRGBA(color: vec4<f32>) -> u32 {
        let rgba = vec4<u32>(color * 255.0);
        return (rgba.a << 24u) | (rgba.r << 16u) | (rgba.g << 8u) | rgba.b;
      }

      // Optimized RGBA unpacking - ARGB format
      fn unpackRGBA(pixelData: u32) -> vec4<f32> {
        return vec4<f32>(
          f32((pixelData >> 16u) & 0xFFu), // R
          f32((pixelData >> 8u) & 0xFFu),  // G
          f32(pixelData & 0xFFu),          // B
          f32((pixelData >> 24u) & 0xFFu)  // A
        ) / 255.0;
      }

      // Extract alpha channel (blur mask) from uint32 - ARGB format
      fn getBlurMask(pixelData: u32) -> f32 {
        return f32((pixelData >> 24u) & 0xFFu);
      }

      @compute @workgroup_size(8, 8)
      fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>) {
        let x = global_id.x;
        let y = global_id.y;
        
        // Early bounds check
        if (x >= uniforms.faceWidth || y >= uniforms.faceHeight) {
          return;
        }
        
        let faceIndex = y * uniforms.faceWidth + x;
        
        // Add bounds check for buffer access to prevent crashes
        if (faceIndex >= arrayLength(&faceData)) {
          return;
        }

        let alpha = faceData[faceIndex] >> 24u;
        if (alpha == 0u) {
          return;
        }

        // Transform the current pixel coordinates
        let point = vec2<f32>(f32(uniforms.faceMinX + x), f32(uniforms.faceMinY + y));
        let transformed = point + f32(alpha)/255.0 * (transformXY(point) - point);
        
        // Convert float coordinates to integers for sampling
        let sampleX = i32(transformed.x);
        let sampleY = i32(transformed.y);
        
        // Sample the image and write to output
        faceData[faceIndex] = packRGBA(sampleImage(sampleX, sampleY));
      }
    `;this.computePipeline=this.device.createComputePipeline({layout:this.pipelineLayout,compute:{module:this.device.createShaderModule({code:e}),entryPoint:"main"}})}createBuffers(e){if(!this.initialized||!this.device){console.error("GPU not initialized");return}const{baseNumPoints:t=0,distortNumPoints:i=0,imageWidth:a=0,imageHeight:s=0,faceMinY:n=0,faceMinX:r=0,faceWidth:u=0,faceHeight:m=0}=e;this.uniformBuffer=this.device.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.meshPointsBuffer=this.device.createBuffer({size:t*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.imagePointsBuffer=this.device.createBuffer({size:t*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.distortPointsBuffer=this.device.createBuffer({size:i*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.modelPointsBuffer=this.device.createBuffer({size:i*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.baseCoeffsBuffer=this.device.createBuffer({size:(t+3)*4*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.model2distortCoeffsBuffer=this.device.createBuffer({size:(i+3)*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.imageDataBuffer=this.device.createBuffer({size:a*s*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.faceDataBuffer=this.device.createBuffer({size:u*m*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.debugBuffer=this.device.createBuffer({size:1024*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.bindGroup=this.device.createBindGroup({layout:this.bindGroupLayout,entries:[{binding:0,resource:{buffer:this.uniformBuffer}},{binding:1,resource:{buffer:this.meshPointsBuffer}},{binding:2,resource:{buffer:this.imagePointsBuffer}},{binding:3,resource:{buffer:this.distortPointsBuffer}},{binding:4,resource:{buffer:this.modelPointsBuffer}},{binding:5,resource:{buffer:this.baseCoeffsBuffer}},{binding:6,resource:{buffer:this.model2distortCoeffsBuffer}},{binding:7,resource:{buffer:this.imageDataBuffer}},{binding:8,resource:{buffer:this.faceDataBuffer}}]})}batchUpdateBuffers(e){if(!this.initialized||!this.device){console.error("GPU not initialized");return}const t=this.device.createCommandEncoder();e.uniforms&&this.uniformBuffer&&this.device.queue.writeBuffer(this.uniformBuffer,0,e.uniforms),e.meshPoints&&this.meshPointsBuffer&&this.device.queue.writeBuffer(this.meshPointsBuffer,0,e.meshPoints),e.imagePoints&&this.imagePointsBuffer&&this.device.queue.writeBuffer(this.imagePointsBuffer,0,e.imagePoints),e.distortPoints&&this.distortPointsBuffer&&this.device.queue.writeBuffer(this.distortPointsBuffer,0,e.distortPoints),e.modelPoints&&this.modelPointsBuffer&&this.device.queue.writeBuffer(this.modelPointsBuffer,0,e.modelPoints),e.baseCoeffs&&this.baseCoeffsBuffer&&this.device.queue.writeBuffer(this.baseCoeffsBuffer,0,e.baseCoeffs),e.model2distortCoeffs&&this.model2distortCoeffsBuffer&&this.device.queue.writeBuffer(this.model2distortCoeffsBuffer,0,e.model2distortCoeffs),e.imageData&&this.imageDataBuffer&&this.device.queue.writeBuffer(this.imageDataBuffer,0,e.imageData),e.faceData&&this.faceDataBuffer&&this.device.queue.writeBuffer(this.faceDataBuffer,0,e.faceData),this.device.queue.submit([t.finish()])}updateUniforms(e){if(!this.initialized||!this.device||!this.uniformBuffer){console.error("GPU not initialized");return}const t=new Uint32Array([e.baseNumPoints||0,e.distortNumPoints||0,e.imageWidth||0,e.imageHeight||0,e.faceMinY||0,e.faceMinX||0,e.faceWidth||0,e.faceHeight||0]);this.device.queue.writeBuffer(this.uniformBuffer,0,t)}updateBuffer(e,t){if(!this.initialized||!this.device){console.error("GPU not initialized");return}this.device.queue.writeBuffer(e,0,t)}updateUintBuffer(e,t){if(!this.initialized||!this.device){console.error("GPU not initialized");return}this.device.queue.writeBuffer(e,0,t)}updateBaseCoeffs(e,t,i,a){if(!this.initialized||!this.device||!this.baseCoeffsBuffer){console.error("GPU not initialized");return}const n=e.length-3+3,r=this.baseCoeffsBuffer.size/4,u=n*4;if(u>r){console.error("Buffer too small for coefficients. Need",u,"floats, buffer has",r);return}const m=new Float32Array(u);for(let C=0;C<n;C++)m[C]=e[C],m[C+n]=t[C];for(let C=0;C<n;C++)m[C+n*2]=i[C],m[C+n*3]=a[C];this.device.queue.writeBuffer(this.baseCoeffsBuffer,0,m)}updateCombinedCoeffs(e,t,i){if(!this.initialized||!this.device){console.error("GPU not initialized");return}const a=new Float32Array(t.length+i.length);for(let s=0;s<t.length;s++)a[s]=t[s],a[s+t.length]=i[s];this.device.queue.writeBuffer(e,0,a)}updateFaceDataWithBlurMask(e){if(!this.initialized||!this.device||!this.faceDataBuffer){console.error("GPU not initialized");return}const t=new Uint32Array(e.length);for(let i=0;i<e.length;i++)t[i]=e[i]<<24;this.device.queue.writeBuffer(this.faceDataBuffer,0,t)}async execute(e,t){if(!this.initialized||!this.device||!this.computePipeline||!this.bindGroup)return console.error("GPU not initialized"),Promise.reject(new Error("GPU not initialized"));const i=8,a=Math.ceil(e/i),s=Math.ceil(t/i);return this.commandEncoder=this.device.createCommandEncoder(),this.computePassEncoder=this.commandEncoder.beginComputePass(),this.computePassEncoder.setPipeline(this.computePipeline),this.computePassEncoder.setBindGroup(0,this.bindGroup),this.computePassEncoder.dispatchWorkgroups(a,s),this.computePassEncoder.end(),this.device.queue.submit([this.commandEncoder.finish()]),Promise.resolve()}async readBuffer(e,t){if(!this.initialized||!this.device)return console.error("GPU not initialized"),new Uint8ClampedArray(0);const i=this.device.createBuffer({size:t,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),a=this.device.createCommandEncoder();a.copyBufferToBuffer(e,0,i,0,t),this.device.queue.submit([a.finish()]),await i.mapAsync(GPUMapMode.READ);const s=i.getMappedRange(),n=new Uint8ClampedArray(s),r=new Uint8ClampedArray(n);return i.unmap(),r}destroy(){this.canvas&&this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas),[this.uniformBuffer,this.meshPointsBuffer,this.imagePointsBuffer,this.distortPointsBuffer,this.modelPointsBuffer,this.baseCoeffsBuffer,this.model2distortCoeffsBuffer,this.imageDataBuffer,this.faceDataBuffer,this.debugBuffer].forEach(t=>{t&&t.destroy()})}}const Ue=f=>({minX:Math.floor(Math.min(...f.map(e=>e[0]))),maxX:Math.ceil(Math.max(...f.map(e=>e[0]))),minY:Math.floor(Math.min(...f.map(e=>e[1]))),maxY:Math.ceil(Math.max(...f.map(e=>e[1]))),minZ:Math.floor(Math.min(...f.map(e=>e[2]))),maxZ:Math.ceil(Math.max(...f.map(e=>e[2])))}),Q=(f,e,t)=>(e[0]-f[0])*(t[1]-f[1])-(e[1]-f[1])*(t[0]-f[0]),K=(f,e)=>Math.hypot(e[0]-f[0],e[1]-f[1]),De=f=>{if(f.length<3)return f;let e=0;for(let s=1;s<f.length;s++)(f[s][1]<f[e][1]||f[s][1]===f[e][1]&&f[s][0]<f[e][0])&&(e=s);const t=f[e],i=f.filter((s,n)=>n!==e).sort((s,n)=>{const r=Math.atan2(s[1]-t[1],s[0]-t[0]),u=Math.atan2(n[1]-t[1],n[0]-t[0]);return r!==u?r-u:K(t,s)-K(t,n)}),a=[t];for(const s of i){for(;a.length>1&&Q(a[a.length-2],a[a.length-1],s)<=0;)a.pop();a.push(s)}return a},Ge=(f,e)=>{if(e.length<3)return!1;for(let t=0;t<e.length;t++){const i=e[t],a=e[(t+1)%e.length];if(Q(i,a,f)<0)return!1}return!0};class Oe{imageLandmarks;imagePoints;imageBBox;nilpotentTPS;baseTPS;activeTPS;canvas;ctx;hull;silhouetteHull;imageSilhouette;mask;offscreenCanvas;offscreenCtx;processingScale;imageData;blurMask;gpu;constructor(e,t,i=1,a){this.imageLandmarks=e,this.imageData=t,this.processingScale=i,this.imagePoints=[];for(const[n,r]of e)this.imagePoints.push([...r]);const s=a||this.getSilhouettePoints();this.silhouetteHull=[];for(let n=0;n<F.path.length;n++)this.silhouetteHull.push(s[F.path[n]]);this.setupTPS(),this.imageSilhouette=[];for(let n=0;n<this.silhouetteHull.length;n++)this.imageSilhouette.push(this.baseTPS.forward(this.silhouetteHull[n]));this.imageBBox=Ue(this.imageSilhouette),this.setupCanvas(),this.createMasks(),this.setupGPU()}setupCanvas(e){this.canvas=document.createElement("canvas"),this.canvas.width=this.imageBBox.maxX-this.imageBBox.minX,this.canvas.height=this.imageBBox.maxY-this.imageBBox.minY,this.canvas.style.position="absolute",this.canvas.style.top=e?.top||this.imageBBox.minY+"px",this.canvas.style.left=e?.left||this.imageBBox.minX+"px",this.canvas.style.transform=e?.transform||"",this.canvas.style.pointerEvents="none",this.canvas.style.background="transparent",this.ctx=this.canvas.getContext("2d"),this.offscreenCanvas=new OffscreenCanvas(this.canvas.width/this.processingScale,this.canvas.height/this.processingScale),this.offscreenCtx=this.offscreenCanvas.getContext("2d"),this.offscreenCtx.fillRect(0,0,this.canvas.width/this.processingScale,this.canvas.height/this.processingScale),this.ctx.fillStyle="transparent",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height)}createMasks(){this.hull=De(this.imageSilhouette),this.mask=new Uint8ClampedArray(this.canvas.width*this.canvas.height);for(let i=0;i<this.canvas.height;i++)for(let a=0;a<this.canvas.width;a++)this.mask[i*this.canvas.width+a]=Ge([a+this.imageBBox.minX,i+this.imageBBox.minY],this.hull)?255:0;let e=new Uint8ClampedArray([...this.mask]);this.blurMask=new Uint8Array(this.canvas.width*this.canvas.height);const t=20;for(let i=0;i<t;i++){for(let a=0;a<this.canvas.height;a++)for(let s=0;s<this.canvas.width;s++){this.blurMask[a*this.canvas.width+s]=0;for(let n=-1;n<=1;n++)for(let r=-1;r<=1;r++){const u=a+n,m=s+r;u<0||u>=this.canvas.height||m<0||m>=this.canvas.width||(this.blurMask[a*this.canvas.width+s]+=e[u*this.canvas.width+m]*Math.pow(.5,2+Math.abs(n)+Math.abs(r)))}}e=new Uint8ClampedArray([...this.blurMask])}}setupGPU(){this.gpu=new Se}async initializeGPU(){try{await this.gpu.initialize(),console.log("GPU initialized successfully");const e=this.getTransformationPoints();this.gpu.createBuffers({baseNumPoints:e.base.length,distortNumPoints:e.distort.length,imageWidth:this.imageData.width,imageHeight:this.imageData.height,faceMinY:this.imageBBox.minY,faceMinX:this.imageBBox.minX,faceWidth:this.imageBBox.maxX-this.imageBBox.minX,faceHeight:this.imageBBox.maxY-this.imageBBox.minY}),this.updateGPUBaseBuffers();const t=new Uint32Array(this.imageData.data.length/4);for(let i=0;i<this.imageData.data.length;i+=4)t[i/4]=this.imageData.data[i+3]<<24|this.imageData.data[i+2]<<16|this.imageData.data[i+1]<<8|this.imageData.data[i];this.gpu.updateUintBuffer(this.gpu.imageDataBuffer,t),this.gpu.updateFaceDataWithBlurMask(this.blurMask),this.updateGPUUniforms(),console.log("GPU buffers initialized successfully")}catch(e){console.error("Failed to initialize GPU:",e)}}updateGPUBaseBuffers(){const e=this.getTransformationPoints();this.gpu.updateBuffer(this.gpu.meshPointsBuffer,new Float32Array(e.base.map(t=>t.slice(0,2)).flat())),this.gpu.updateBuffer(this.gpu.imagePointsBuffer,new Float32Array(this.imagePoints.map(t=>t.slice(0,2)).flat())),this.gpu.updateBuffer(this.gpu.distortPointsBuffer,new Float32Array(e.distort.map(t=>t.slice(0,2)).flat())),this.gpu.updateBuffer(this.gpu.modelPointsBuffer,new Float32Array(e.base.map(t=>t.slice(0,2)).flat())),this.gpu.updateBaseCoeffs(this.baseTPS.inverseParameters.Xc,this.baseTPS.inverseParameters.Yc,this.baseTPS.forwardParameters.Xc,this.baseTPS.forwardParameters.Yc)}updateGPUUniforms(){const e=this.getTransformationPoints();this.gpu.updateUniforms({baseNumPoints:e.base.length,distortNumPoints:e.distort.length,imageWidth:this.imageData.width,imageHeight:this.imageData.height,faceMinY:this.imageBBox.minY,faceMinX:this.imageBBox.minX,faceWidth:this.imageBBox.maxX-this.imageBBox.minX,faceHeight:this.imageBBox.maxY-this.imageBBox.minY})}async drawGPU(){if(!this.gpu.initialized){console.log("GPU not ready, falling back to CPU"),this.draw();return}const e=this.imageBBox.maxX-this.imageBBox.minX,t=this.imageBBox.maxY-this.imageBBox.minY;this.updateGPUUniforms();try{await this.gpu.execute(e,t);const i=await this.gpu.readBuffer(this.gpu.faceDataBuffer,e*t*4),a=new ImageData(i,e,t);this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.offscreenCtx.putImageData(a,0,0),this.ctx.drawImage(this.offscreenCanvas,0,0,this.canvas.width,this.canvas.height),this.gpu.updateFaceDataWithBlurMask(this.blurMask)}catch(i){console.error("Error executing GPU shader:",i),this.draw()}}draw(){const e=Math.floor(this.canvas.width/this.processingScale),t=Math.floor(this.canvas.height/this.processingScale),i=new Uint8ClampedArray(e*t*4).fill(0);let a=0;for(let s=0;s<this.canvas.height;s+=this.processingScale){let n=0;for(let r=0;r<this.canvas.width;r+=this.processingScale){const u=this.blurMask[s*this.canvas.width+r];if(u===0){n++;continue}const m=(a*e+n)*4,[C,k]=[r+this.imageBBox.minX,s+this.imageBBox.minY],[I,v]=this.transformXY(C,k),[y,Y]=[I,v],M=u/255,[A,O]=[C+M*(y-C),k+M*(Y-k)],D=(Math.round(O)*this.imageData.width+Math.round(A))*4;D>=0&&D<this.imageData.data.length-3&&Math.round(A)>=0&&Math.round(A)<this.imageData.width&&Math.round(O)>=0&&Math.round(O)<this.imageData.height&&(i[m]=this.imageData.data[D],i[m+1]=this.imageData.data[D+1],i[m+2]=this.imageData.data[D+2],i[m+3]=this.imageData.data[D+3]),n++}a++}this.offscreenCtx.putImageData(new ImageData(i,e,t),0,0),this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.ctx.drawImage(this.offscreenCanvas,0,0,this.canvas.width,this.canvas.height)}destroy(){this.gpu&&this.gpu.destroy(),this.canvas&&this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas)}getCanvas(){return this.canvas}getMask(){return this.mask}getImageBBox(){return this.imageBBox}}function _e(f=0,e=0){const t=[];for(let i=0;i<f;i++){t[i]=[];for(let a=0;a<e;a++)t[i][a]=0}return t}function Me(f){if(f.length!==f[0].length)return;let e=0,t=0,i=0,a=f.length,s=0,n=[],r=[];for(e=0;e<a;e+=1)for(n[n.length]=[],r[r.length]=[],i=0;i<a;i+=1)e==i?n[e][i]=1:n[e][i]=0,r[e][i]=f[e][i];for(e=0;e<a;e+=1){if(s=r[e][e],s==0){for(t=e+1;t<a;t+=1)if(r[t][e]!=0){for(i=0;i<a;i++)s=r[e][i],r[e][i]=r[t][i],r[t][i]=s,s=n[e][i],n[e][i]=n[t][i],n[t][i]=s;break}if(s=r[e][e],s==0)return}for(i=0;i<a;i++)r[e][i]=r[e][i]/s,n[e][i]=n[e][i]/s;for(t=0;t<a;t++)if(t!=e)for(s=r[t][e],i=0;i<a;i++)r[t][i]-=s*r[e][i],n[t][i]-=s*n[e][i]}return n}class ke{_sourcePoints;_targetPoints;_forwardParameters;_inverseParameters;constructor(){this._sourcePoints=[],this._targetPoints=[],this._forwardParameters={},this._inverseParameters={}}get sourcePoints(){return this._sourcePoints}get targetPoints(){return this._targetPoints}get forwardParameters(){return this._forwardParameters}set forwardParameters(e){this._forwardParameters=e}get inverseParameters(){return this._inverseParameters}set inverseParameters(e){this._inverseParameters=e}calculate(e,t){this._sourcePoints=e,this._targetPoints=t,this._forwardParameters=this.__calculateParameters(e,t),this._inverseParameters=this.__calculateParameters(t,e)}__calculateParameters(e,t){throw new Error("__calculateParameters must be implemented by subclass")}}class Ee extends ke{invA;kernelCache;constructor(e,t){super(),this.invA=null,this.kernelCache=new Map,e&&t&&this.calculate(e,t)}forward(e){return this.__isEmpty(this._forwardParameters)?e:this.__transform(e,this._forwardParameters)}inverse(e){return this.__isEmpty(this._inverseParameters)?e:this.__transform(e,this._inverseParameters)}__transform(e,t){let i=t.Xc[0]+t.Xc[1]*e[0]+t.Xc[2]*e[1],a=t.Yc[0]+t.Yc[1]*e[0]+t.Yc[2]*e[1];for(let s=0;s<t.m;s++){const n=this.__kernelFunction(e[0]-t.sourcePoints[s][0],e[1]-t.sourcePoints[s][1]);i+=t.Xc[s+3]*n,a+=t.Yc[s+3]*n}return[i,a]}__calculateParameters(e,t){if(e.length!==t.length)return console.warn("Number of points do not match!"),null;const i=e.length;let a=_e(i+3,i+3);for(let r=0;r<i;r++)a[0][3+r]=1,a[1][3+r]=e[r][0],a[2][3+r]=e[r][1],a[3+r][0]=1,a[3+r][1]=e[r][0],a[3+r][2]=e[r][1];for(let r=0;r<i;r++)for(let u=0;u<i;u++)a[r+3][u+3]=this.__kernelFunction(e[r][0]-e[u][0],e[r][1]-e[u][1]),a[u+3][r+3]=a[r+3][u+3];if(this.invA=Me(a),this.invA===null)return null;let s=new Float64Array(i+3),n=new Float64Array(i+3);for(let r=0;r<i+3;r++)for(let u=0;u<i;u++)s[r]+=this.invA[r][u+3]*t[u][0],n[r]+=this.invA[r][u+3]*t[u][1];return{m:i,Xc:s,Yc:n,sourcePoints:e}}updateParameters(e){this._targetPoints=e;const t=this.targetPoints.length;let i=new Float64Array(t+3),a=new Float64Array(t+3);for(let s=0;s<t+3;s++)for(let n=0;n<t;n++)i[s]+=this.invA[s][n+3]*e[n][0],a[s]+=this.invA[s][n+3]*e[n][1];return this._forwardParameters.Xc=[...i],this._forwardParameters.Yc=[...a],{Xc:i,Yc:a}}updateInverseParameters(e){this._targetPoints=[...e];const t=this.__calculateParameters(this._targetPoints,this._sourcePoints);return t&&!this.__isEmpty(t)&&(this._inverseParameters=t,this._inverseParameters.Yc[1]=0,this._inverseParameters.Yc[2]=1,this._inverseParameters.Xc[1]=1,this._inverseParameters.Xc[2]=0),this._inverseParameters}__kernelFunction(e,t){if(e==0&&t==0)return 0;const i=e*e+t*t;return i*Math.log(i)}__isEmpty(e){return Object.keys(e).length===0&&e.constructor===Object}}export{Oe as B,Ye as P,Ee as T};

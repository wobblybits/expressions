const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/face_mesh-C4n09Vz3.js","assets/_commonjsHelpers-Cpj98o6Y.js","assets/camera_utils-c8ZgCaOI.js"])))=>i.map(i=>d[i]);
import{b as V,G as ht,t as ne,w as fe,I as Re,H as p,A as q,i as oe,K as ut,z as Ne,m as He,d as lt,L as Z,q as dt,M as K}from"./web-BjSrF1zk.js";import{m as W,F as mt,b as Y,E as gt}from"./Face-CMEODpwO.js";import{s as ae,T as Q,f as M}from"./TPS-DfqRdrRt.js";import{_ as We}from"./preload-helper-BrT8b0UT.js";import{C as pt}from"./ClientOnly-B3hFWBc-.js";const vt={silhouette:{path:[10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109],closed:!0,name:"Silhouette",description:"Starting at the top of the forehead and going clockwise, outline the face."}},bt={rightEyebrow:{path:[46,53,52,65,55],closed:!0,name:"Left eyebrow",description:"Draw a line from left to right representing the left eyebrow."},leftEyebrow:{path:[276,283,282,295,285],closed:!0,name:"Right eyebrow",description:"Draw a line from right to left representing the right eyebrow."},leftEye:{path:[263,466,388,387,386,385,384,398,362,382,381,380,374,373,390,249],closed:!0,name:"Right eye",description:"Starting at the outer right corner of the right eye, draw a counter-clockwise path that follows the outer edge of the eye."},rightEye:{path:[33,246,161,160,159,158,157,173,133,155,154,153,144,163,7],closed:!0,name:"Left eye",description:"Starting at the outer left corner of the left eye, draw a clockwise path that follows the outer edge of the eye."}},Pt={"outer lips":{path:[61,185,40,39,37,0,267,269,270,409,291,375,321,405,314,17,84,181,91,146],closed:!0,name:"Lips",description:"Starting at the outer left corner of the lips, draw a clockwise path that follows the outer edge of the lips."},"inner lips":{path:[78,191,80,81,82,13,312,311,310,415,308,324,318,402,317,14,87,178,88,95],closed:!0,name:"Mouth",description:"Starting at the outer left corner of the mouth, draw a clockwise path that follows the outer edge of the mouth (inner edge of the lips)."}},re={silhouette:vt,eyes:bt,mouth:Pt};class yt{device;context;canvas;commandEncoder;computePassEncoder;initialized;uniformBuffer;meshPointsBuffer;imagePointsBuffer;distortPointsBuffer;modelPointsBuffer;baseCoeffsBuffer;model2distortCoeffsBuffer;imageDataBuffer;faceDataBuffer;debugBuffer;bindGroup;bindGroupLayout;pipelineLayout;computePipeline;constructor(){this.device=null,this.context=null,this.canvas=null,this.commandEncoder=null,this.computePassEncoder=null,this.initialized=!1,this.uniformBuffer=null,this.meshPointsBuffer=null,this.imagePointsBuffer=null,this.distortPointsBuffer=null,this.modelPointsBuffer=null,this.baseCoeffsBuffer=null,this.model2distortCoeffsBuffer=null,this.imageDataBuffer=null,this.faceDataBuffer=null,this.debugBuffer=null,this.bindGroup=null,this.bindGroupLayout=null,this.pipelineLayout=null,this.computePipeline=null}async initialize(){try{if(!navigator.gpu)return console.error("WebGPU not supported"),!1;const e=await navigator.gpu.requestAdapter();return e?(this.device=await e.requestDevice({requiredLimits:{maxStorageBuffersPerShaderStage:10}}),this.canvas=document.createElement("canvas"),this.canvas.style.display="none",document.body.appendChild(this.canvas),this.context=this.canvas.getContext("webgpu"),this.context?(await this.setupComputeShader(),this.initialized=!0,!0):(console.error("WebGPU context not available"),!1)):(console.error("No WebGPU adapter found"),!1)}catch(e){return console.error("Failed to initialize WebGPU:",e),!1}}async setupComputeShader(){if(!this.device)throw new Error("Device not initialized");this.bindGroupLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:6,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:7,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:8,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),this.pipelineLayout=this.device.createPipelineLayout({bindGroupLayouts:[this.bindGroupLayout]});const e=`
      struct Uniforms {
        baseNumPoints: u32,
        distortNumPoints: u32,
        imageWidth: u32,
        imageHeight: u32,
        faceMinY: u32,
        faceMinX: u32,
        faceWidth: u32,
        faceHeight: u32,
      }

      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      @group(0) @binding(1) var<storage, read> meshPoints: array<f32>;
      @group(0) @binding(2) var<storage, read> imagePoints: array<f32>;
      @group(0) @binding(3) var<storage, read> distortPoints: array<f32>;
      @group(0) @binding(4) var<storage, read> modelPoints: array<f32>;
      @group(0) @binding(5) var<storage, read> baseCoeffs: array<f32>;
      @group(0) @binding(6) var<storage, read> model2distortCoeffs: array<f32>;
      @group(0) @binding(7) var<storage, read> imageData: array<u32>;
      @group(0) @binding(8) var<storage, read_write> faceData: array<u32>;

      // Radial basis function - r^2 * log(r) using built-in length function
      fn kernelFunction(dx: f32, dy: f32) -> f32 {
        if (dx == 0.0 && dy == 0.0) {
          return 0.0;
        }
        let dist = length(vec2<f32>(dx, dy));
        return dist * dist * log(dist * dist);
      }

      // Transform XY function with vec2 optimizations
      fn transformXY(point: vec2<f32>) -> vec2<f32> {
        let baseNumPoints = uniforms.baseNumPoints;
        let coeffsOffset = baseNumPoints + 3u;
        
        // Validate coefficient array bounds
        if (baseNumPoints == 0u || coeffsOffset * 4u > arrayLength(&baseCoeffs)) {
          return point; // Return original point if coefficients are invalid
        }
        
        // Step 1: baseTPS.inverse(point) - use inverse coefficients (offset 0)
        var baseInverse = vec2<f32>(0.0, 0.0);
        {
          var Xo = baseCoeffs[0] + baseCoeffs[1] * point.x + baseCoeffs[2] * point.y;
          var Yo = baseCoeffs[coeffsOffset] + baseCoeffs[coeffsOffset + 1] * point.x + baseCoeffs[coeffsOffset + 2] * point.y;
          
          for (var r = 0u; r < baseNumPoints; r++) {
            let sourcePoint = vec2<f32>(imagePoints[r * 2u], imagePoints[r * 2u + 1u]);
            let diff = point - sourcePoint;
            let tmp = kernelFunction(diff.x, diff.y);
            Xo += baseCoeffs[r + 3u] * tmp;
            Yo += baseCoeffs[coeffsOffset + r + 3u] * tmp;
          }
          baseInverse = vec2<f32>(Xo, Yo);
        }
        
        // Step 2: activeTPS.inverse(baseInverse) - use forward coefficients with swapped points
        var activeInverse = vec2<f32>(0.0, 0.0);
        {
          let distortNumPoints = uniforms.distortNumPoints;
          let distortCoeffsOffset = distortNumPoints + 3u;
          
          // Validate model2distort coefficients
          if (distortNumPoints == 0u || distortCoeffsOffset * 2u > arrayLength(&model2distortCoeffs)) {
            return baseInverse; // Return base inverse if coefficients are invalid
          }
          
          // For inverse transformation, we need to find the input that produces baseInverse as output
          // Since we have inverse coefficients, we can use them directly
          var Xo = model2distortCoeffs[0] + model2distortCoeffs[1] * baseInverse.x + model2distortCoeffs[2] * baseInverse.y;
          var Yo = model2distortCoeffs[distortCoeffsOffset] + model2distortCoeffs[distortCoeffsOffset + 1] * baseInverse.x + model2distortCoeffs[distortCoeffsOffset + 2] * baseInverse.y;
          
          for (var r = 0u; r < distortNumPoints; r++) {
            // For inverse transformation, use distortPoints as source (since we want to map back to model)
            let sourcePoint = vec2<f32>(distortPoints[r * 2u], distortPoints[r * 2u + 1u]);
            let diff = baseInverse - sourcePoint;
            let tmp = kernelFunction(diff.x, diff.y);
            Xo += model2distortCoeffs[r + 3u] * tmp;
            Yo += model2distortCoeffs[distortCoeffsOffset + r + 3u] * tmp;
          }
          activeInverse = vec2<f32>(Xo, Yo);
        }
        
        // Step 3: baseTPS.forward(activeInverse) - use forward coefficients (offset 2*coeffsOffset)
        var result = vec2<f32>(0.0, 0.0);
        {
          var Xo = baseCoeffs[coeffsOffset * 2u] + baseCoeffs[coeffsOffset * 2u + 1u] * activeInverse.x + baseCoeffs[coeffsOffset * 2u + 2u] * activeInverse.y;
          var Yo = baseCoeffs[coeffsOffset * 3u] + baseCoeffs[coeffsOffset * 3u + 1u] * activeInverse.x + baseCoeffs[coeffsOffset * 3u + 2u] * activeInverse.y;
          
          for (var r = 0u; r < baseNumPoints; r++) {
            let sourcePoint = vec2<f32>(meshPoints[r * 2u], meshPoints[r * 2u + 1u]);
            let diff = activeInverse - sourcePoint;
            let tmp = kernelFunction(diff.x, diff.y);
            Xo += baseCoeffs[coeffsOffset * 2u + r + 3u] * tmp;
            Yo += baseCoeffs[coeffsOffset * 3u + r + 3u] * tmp;
          }
          result = vec2<f32>(Xo, Yo);
        }
        
        return result;
      }

      // Sample image data with bounds checking - use optimized unpacking
      fn sampleImage(x: i32, y: i32) -> vec4<f32> {
        // if (x < 0 || x >= i32(uniforms.imageWidth) || y < 0 || y >= i32(uniforms.imageHeight)) {
        //   return vec4<f32>(0.0, 0.0, 0.0, 0.0);
        // }
        
        let index = (u32(y) % uniforms.imageHeight) * uniforms.imageWidth + (u32(x) % uniforms.imageWidth);
        let pixelData = imageData[index];
        
        // Use the optimized unpacking function
        return unpackRGBA(pixelData);
      }

      // Optimized RGBA packing using vector operations - ARGB format to match unpacking
      fn packRGBA(color: vec4<f32>) -> u32 {
        let rgba = vec4<u32>(color * 255.0);
        return (rgba.a << 24u) | (rgba.r << 16u) | (rgba.g << 8u) | rgba.b;
      }

      // Optimized RGBA unpacking - ARGB format
      fn unpackRGBA(pixelData: u32) -> vec4<f32> {
        return vec4<f32>(
          f32((pixelData >> 16u) & 0xFFu), // R
          f32((pixelData >> 8u) & 0xFFu),  // G
          f32(pixelData & 0xFFu),          // B
          f32((pixelData >> 24u) & 0xFFu)  // A
        ) / 255.0;
      }

      // Extract alpha channel (blur mask) from uint32 - ARGB format
      fn getBlurMask(pixelData: u32) -> f32 {
        return f32((pixelData >> 24u) & 0xFFu);
      }

      @compute @workgroup_size(8, 8)
      fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>) {
        let x = global_id.x;
        let y = global_id.y;
        
        // Early bounds check
        if (x >= uniforms.faceWidth || y >= uniforms.faceHeight) {
          return;
        }
        
        let faceIndex = y * uniforms.faceWidth + x;
        
        // Add bounds check for buffer access to prevent crashes
        if (faceIndex >= arrayLength(&faceData)) {
          return;
        }

        let alpha = faceData[faceIndex] >> 24u;
        if (alpha == 0u) {
          return;
        }

        // Transform the current pixel coordinates
        let point = vec2<f32>(f32(uniforms.faceMinX + x), f32(uniforms.faceMinY + y));
        let transformed = point + f32(alpha)/255.0 * (transformXY(point) - point);
        
        // Convert float coordinates to integers for sampling
        let sampleX = i32(transformed.x);
        let sampleY = i32(transformed.y);
        
        // Sample the image and write to output
        faceData[faceIndex] = packRGBA(sampleImage(sampleX, sampleY));
      }
    `;this.computePipeline=this.device.createComputePipeline({layout:this.pipelineLayout,compute:{module:this.device.createShaderModule({code:e}),entryPoint:"main"}})}createBuffers(e){if(!this.initialized||!this.device){console.error("GPU not initialized");return}const{baseNumPoints:t=0,distortNumPoints:i=0,imageWidth:a=0,imageHeight:c=0,faceMinY:B=0,faceMinX:f=0,faceWidth:o=0,faceHeight:g=0}=e;this.uniformBuffer=this.device.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.meshPointsBuffer=this.device.createBuffer({size:t*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.imagePointsBuffer=this.device.createBuffer({size:t*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.distortPointsBuffer=this.device.createBuffer({size:i*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.modelPointsBuffer=this.device.createBuffer({size:i*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.baseCoeffsBuffer=this.device.createBuffer({size:(t+3)*4*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.model2distortCoeffsBuffer=this.device.createBuffer({size:(i+3)*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.imageDataBuffer=this.device.createBuffer({size:a*c*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.faceDataBuffer=this.device.createBuffer({size:o*g*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.debugBuffer=this.device.createBuffer({size:1024*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.bindGroup=this.device.createBindGroup({layout:this.bindGroupLayout,entries:[{binding:0,resource:{buffer:this.uniformBuffer}},{binding:1,resource:{buffer:this.meshPointsBuffer}},{binding:2,resource:{buffer:this.imagePointsBuffer}},{binding:3,resource:{buffer:this.distortPointsBuffer}},{binding:4,resource:{buffer:this.modelPointsBuffer}},{binding:5,resource:{buffer:this.baseCoeffsBuffer}},{binding:6,resource:{buffer:this.model2distortCoeffsBuffer}},{binding:7,resource:{buffer:this.imageDataBuffer}},{binding:8,resource:{buffer:this.faceDataBuffer}}]})}batchUpdateBuffers(e){if(!this.initialized||!this.device){console.error("GPU not initialized");return}const t=this.device.createCommandEncoder();e.uniforms&&this.uniformBuffer&&this.device.queue.writeBuffer(this.uniformBuffer,0,e.uniforms),e.meshPoints&&this.meshPointsBuffer&&this.device.queue.writeBuffer(this.meshPointsBuffer,0,e.meshPoints),e.imagePoints&&this.imagePointsBuffer&&this.device.queue.writeBuffer(this.imagePointsBuffer,0,e.imagePoints),e.distortPoints&&this.distortPointsBuffer&&this.device.queue.writeBuffer(this.distortPointsBuffer,0,e.distortPoints),e.modelPoints&&this.modelPointsBuffer&&this.device.queue.writeBuffer(this.modelPointsBuffer,0,e.modelPoints),e.baseCoeffs&&this.baseCoeffsBuffer&&this.device.queue.writeBuffer(this.baseCoeffsBuffer,0,e.baseCoeffs),e.model2distortCoeffs&&this.model2distortCoeffsBuffer&&this.device.queue.writeBuffer(this.model2distortCoeffsBuffer,0,e.model2distortCoeffs),e.imageData&&this.imageDataBuffer&&this.device.queue.writeBuffer(this.imageDataBuffer,0,e.imageData),e.faceData&&this.faceDataBuffer&&this.device.queue.writeBuffer(this.faceDataBuffer,0,e.faceData),this.device.queue.submit([t.finish()])}updateUniforms(e){if(!this.initialized||!this.device||!this.uniformBuffer){console.error("GPU not initialized");return}const t=new Uint32Array([e.baseNumPoints||0,e.distortNumPoints||0,e.imageWidth||0,e.imageHeight||0,e.faceMinY||0,e.faceMinX||0,e.faceWidth||0,e.faceHeight||0]);this.device.queue.writeBuffer(this.uniformBuffer,0,t)}updateBuffer(e,t){if(!this.initialized||!this.device){console.error("GPU not initialized");return}this.device.queue.writeBuffer(e,0,t)}updateUintBuffer(e,t){if(!this.initialized||!this.device){console.error("GPU not initialized");return}this.device.queue.writeBuffer(e,0,t)}updateBaseCoeffs(e,t,i,a){if(!this.initialized||!this.device||!this.baseCoeffsBuffer){console.error("GPU not initialized");return}const B=e.length-3+3,f=this.baseCoeffsBuffer.size/4,o=B*4;if(o>f){console.error("Buffer too small for coefficients. Need",o,"floats, buffer has",f);return}const g=new Float32Array(o);for(let b=0;b<B;b++)g[b]=e[b],g[b+B]=t[b];for(let b=0;b<B;b++)g[b+B*2]=i[b],g[b+B*3]=a[b];this.device.queue.writeBuffer(this.baseCoeffsBuffer,0,g)}updateCombinedCoeffs(e,t,i){if(!this.initialized||!this.device){console.error("GPU not initialized");return}const a=new Float32Array(t.length+i.length);for(let c=0;c<t.length;c++)a[c]=t[c],a[c+t.length]=i[c];this.device.queue.writeBuffer(e,0,a)}updateFaceDataWithBlurMask(e){if(!this.initialized||!this.device||!this.faceDataBuffer){console.error("GPU not initialized");return}const t=new Uint32Array(e.length);for(let i=0;i<e.length;i++)t[i]=e[i]<<24;this.device.queue.writeBuffer(this.faceDataBuffer,0,t)}async execute(e,t){if(!this.initialized||!this.device||!this.computePipeline||!this.bindGroup)return console.error("GPU not initialized"),Promise.reject(new Error("GPU not initialized"));const i=8,a=Math.ceil(e/i),c=Math.ceil(t/i);return this.commandEncoder=this.device.createCommandEncoder(),this.computePassEncoder=this.commandEncoder.beginComputePass(),this.computePassEncoder.setPipeline(this.computePipeline),this.computePassEncoder.setBindGroup(0,this.bindGroup),this.computePassEncoder.dispatchWorkgroups(a,c),this.computePassEncoder.end(),this.device.queue.submit([this.commandEncoder.finish()]),Promise.resolve()}async readBuffer(e,t){if(!this.initialized||!this.device)return console.error("GPU not initialized"),new Uint8ClampedArray(0);const i=this.device.createBuffer({size:t,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),a=this.device.createCommandEncoder();a.copyBufferToBuffer(e,0,i,0,t),this.device.queue.submit([a.finish()]),await i.mapAsync(GPUMapMode.READ);const c=i.getMappedRange(),B=new Uint8ClampedArray(c),f=new Uint8ClampedArray(B);return i.unmap(),f}destroy(){this.canvas&&this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas),[this.uniformBuffer,this.meshPointsBuffer,this.imagePointsBuffer,this.distortPointsBuffer,this.modelPointsBuffer,this.baseCoeffsBuffer,this.model2distortCoeffsBuffer,this.imageDataBuffer,this.faceDataBuffer,this.debugBuffer].forEach(t=>{t&&t.destroy()})}}const qe=d=>({minX:Math.floor(Math.min(...d.map(e=>e[0]))),maxX:Math.ceil(Math.max(...d.map(e=>e[0]))),minY:Math.floor(Math.min(...d.map(e=>e[1]))),maxY:Math.ceil(Math.max(...d.map(e=>e[1]))),minZ:Math.floor(Math.min(...d.map(e=>e[2]))),maxZ:Math.ceil(Math.max(...d.map(e=>e[2])))}),Ve=(d,e,t)=>(e[0]-d[0])*(t[1]-d[1])-(e[1]-d[1])*(t[0]-d[0]),je=(d,e)=>Math.hypot(e[0]-d[0],e[1]-d[1]),xt=d=>{if(d.length<3)return d;let e=0;for(let c=1;c<d.length;c++)(d[c][1]<d[e][1]||d[c][1]===d[e][1]&&d[c][0]<d[e][0])&&(e=c);const t=d[e],i=d.filter((c,B)=>B!==e).sort((c,B)=>{const f=Math.atan2(c[1]-t[1],c[0]-t[0]),o=Math.atan2(B[1]-t[1],B[0]-t[0]);return f!==o?f-o:je(t,c)-je(t,B)}),a=[t];for(const c of i){for(;a.length>1&&Ve(a[a.length-2],a[a.length-1],c)<=0;)a.pop();a.push(c)}return a},Bt=(d,e)=>{if(e.length<3)return!1;for(let t=0;t<e.length;t++){const i=e[t],a=e[(t+1)%e.length];if(Ve(i,a,d)<0)return!1}return!0};class wt{imageLandmarks;cameraLandmarks;baseTransform;imagePoints;cameraPoints;imageBBox;cameraBBox;nilpotentTPS;baseTPS;activeTPS;canvas;ctx;hull;silhouetteHull;imageSilhouette;mask;forwardMap;inverseMap;offscreenCanvas;offscreenCtx;processingScale;imageData;landmarkSkip;blurMask;gpu;constructor(e,t,i,a=2){this.imageLandmarks=e,this.cameraLandmarks=t,this.imagePoints=[],this.cameraPoints=[],this.imageData=i,this.landmarkSkip=2,this.silhouetteHull=[];for(let f=0;f<ae.path.length;f++)this.silhouetteHull.push([t[ae.path[f]][0],t[ae.path[f]][1]]);for(const[f,o]of e){const g=parseInt(f);g<t.length?(this.imagePoints.push(o.slice(0,2)),this.cameraPoints.push([t[g][0],t[g][1]])):console.log("Image landmark index out of bounds:",g)}this.gpu=new yt,this.baseTPS=new Q(this.cameraPoints,this.imagePoints),console.log(this.baseTPS),this.nilpotentTPS=new Q(this.cameraLandmarks.filter((f,o)=>o%this.landmarkSkip===0).map(f=>f.slice(0,2)),this.cameraLandmarks.filter((f,o)=>o%this.landmarkSkip===0).map(f=>f.slice(0,2))),this.activeTPS=this.nilpotentTPS,this.imageSilhouette=[];for(let f=0;f<this.silhouetteHull.length;f++)this.imageSilhouette.push(this.baseTPS.forward(this.silhouetteHull[f]));this.imageBBox=qe(this.imageSilhouette),console.log(this.imageBBox),this.cameraBBox=qe(this.silhouetteHull),this.inverseMap=this.precomputeTransformationMap(this.baseTPS),this.canvas=document.createElement("canvas"),this.canvas.width=this.imageBBox.maxX-this.imageBBox.minX,this.canvas.height=this.imageBBox.maxY-this.imageBBox.minY,this.canvas.style.position="absolute",this.canvas.style.top=this.imageBBox.minY+"px",this.canvas.style.left=this.imageBBox.minX+"px",this.canvas.style.pointerEvents="none",this.canvas.style.background="transparent",this.ctx=this.canvas.getContext("2d"),this.offscreenCanvas=new OffscreenCanvas(this.canvas.width/a,this.canvas.height/a),this.processingScale=a,this.offscreenCtx=this.offscreenCanvas.getContext("2d"),this.offscreenCtx.fillRect(0,0,this.canvas.width/this.processingScale,this.canvas.height/this.processingScale),this.ctx.fillStyle="transparent",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.hull=xt(this.imageSilhouette),this.mask=new Uint8ClampedArray(this.canvas.width*this.canvas.height);for(let f=0;f<this.canvas.height;f++)for(let o=0;o<this.canvas.width;o++)this.mask[f*this.canvas.width+o]=Bt([o+this.imageBBox.minX,f+this.imageBBox.minY],this.hull)?255:0;let c=new Uint8ClampedArray([...this.mask]);this.blurMask=new Uint8ClampedArray(this.canvas.width*this.canvas.height);const B=20;for(let f=0;f<B;f++){for(let o=0;o<this.canvas.height;o++)for(let g=0;g<this.canvas.width;g++){this.blurMask[o*this.canvas.width+g]=0;for(let b=-1;b<=1;b++)for(let A=-1;A<=1;A++){const C=o+b,_=g+A;C<0||C>=this.canvas.height||_<0||_>=this.canvas.width||(this.blurMask[o*this.canvas.width+g]+=c[C*this.canvas.width+_]*Math.pow(.5,2+Math.abs(b)+Math.abs(A)))}}c=new Uint8ClampedArray([...this.blurMask])}return console.log(this.blurMask),this.gpu.initialize().then(()=>{console.log("GPU initialized successfully"),this.gpu.createBuffers({baseNumPoints:this.cameraPoints.length,distortNumPoints:this.cameraLandmarks.filter((o,g)=>g%this.landmarkSkip===0).length,imageWidth:this.imageData.width,imageHeight:this.imageData.height,faceMinY:this.imageBBox.minY,faceMinX:this.imageBBox.minX,faceWidth:this.imageBBox.maxX-this.imageBBox.minX,faceHeight:this.imageBBox.maxY-this.imageBBox.minY}),this.gpu.updateBuffer(this.gpu.meshPointsBuffer,new Float32Array(this.cameraPoints.map(o=>o.slice(0,2)).flat())),this.gpu.updateBuffer(this.gpu.imagePointsBuffer,new Float32Array(this.imagePoints.map(o=>o.slice(0,2)).flat())),this.gpu.updateBuffer(this.gpu.distortPointsBuffer,new Float32Array(this.cameraLandmarks.filter((o,g)=>g%this.landmarkSkip===0).map(o=>o.slice(0,2)).flat())),this.gpu.updateBuffer(this.gpu.modelPointsBuffer,new Float32Array(this.cameraLandmarks.filter((o,g)=>g%this.landmarkSkip===0).map(o=>o.slice(0,2)).flat())),console.log(this.baseTPS.inverseParameters.Xc,this.baseTPS.inverseParameters.Yc,this.baseTPS.forwardParameters.Xc,this.baseTPS.forwardParameters.Yc),this.gpu.updateBaseCoeffs(this.baseTPS.inverseParameters.Xc,this.baseTPS.inverseParameters.Yc,this.baseTPS.forwardParameters.Xc,this.baseTPS.forwardParameters.Yc),this.gpu.updateCombinedCoeffs(this.gpu.model2distortCoeffsBuffer,this.activeTPS.inverseParameters.Xc,this.activeTPS.inverseParameters.Yc);const f=new Uint32Array(this.imageData.data.length/4);for(let o=0;o<this.imageData.data.length;o+=4)f[o/4]=this.imageData.data[o+3]<<24|this.imageData.data[o+2]<<16|this.imageData.data[o+1]<<8|this.imageData.data[o];this.gpu.updateUintBuffer(this.gpu.imageDataBuffer,f),this.gpu.updateFaceDataWithBlurMask(this.blurMask),this.gpu.updateUniforms({baseNumPoints:this.cameraPoints.length,distortNumPoints:this.cameraLandmarks.filter((o,g)=>g%this.landmarkSkip===0).length,imageWidth:this.imageData.width,imageHeight:this.imageData.height,faceMinY:this.imageBBox.minY,faceMinX:this.imageBBox.minX,faceWidth:this.imageBBox.maxX-this.imageBBox.minX,faceHeight:this.imageBBox.maxY-this.imageBBox.minY}),console.log("GPU buffers initialized successfully")}).catch(f=>{console.error("Failed to initialize GPU:",f)}),this}precomputeTransformationMap(e){const t=[];for(let i=this.imageBBox.minY;i<this.imageBBox.maxY;i++)for(let a=this.imageBBox.minX;a<this.imageBBox.maxX;a++){const c=e.inverse([a,i,0]);t.push(c)}return t}updateActiveTPS(e){return e.length!=this.cameraLandmarks.length?!1:(this.activeTPS=new Q(this.cameraLandmarks.filter((t,i)=>i%this.landmarkSkip===0).map(t=>t.slice(0,2)),e.filter((t,i)=>i%this.landmarkSkip===0).map(t=>t.slice(0,2))),!0)}updateActiveTargets(e){const t=this.activeTPS.updateInverseParameters(e.filter((i,a)=>a%this.landmarkSkip===0).map(i=>i.slice(0,2)));return t&&this.gpu.initialized&&(this.gpu.updateBuffer(this.gpu.distortPointsBuffer,new Float32Array(e.filter((i,a)=>a%this.landmarkSkip===0).map(i=>i.slice(0,2)).flat())),this.gpu.updateCombinedCoeffs(this.gpu.model2distortCoeffsBuffer,t.Xc,t.Yc)),!0}transformXY(e,t){const i=this.inverseMap[(t-this.imageBBox.minY)*(this.imageBBox.maxX-this.imageBBox.minX)+e-this.imageBBox.minX];return this.baseTPS.forward(this.activeTPS.inverse(i))}draw(){const e=Math.floor(this.canvas.width/this.processingScale),t=Math.floor(this.canvas.height/this.processingScale),i=new Uint8ClampedArray(e*t*4).fill(0);let a=0;for(let c=0;c<this.canvas.height;c+=this.processingScale){let B=0;for(let f=0;f<this.canvas.width;f+=this.processingScale){const o=this.blurMask[c*this.canvas.width+f];if(o===0){B++;continue}const g=(a*e+B)*4,[b,A]=[f+this.imageBBox.minX,c+this.imageBBox.minY],[C,_]=this.transformXY(b,A),[E,P]=[C,_],v=o/255,[y,F]=[b+v*(E-b),A+v*(P-A)],$=(Math.round(F)*this.imageData.width+Math.round(y))*4;$>=0&&$<this.imageData.data.length-3&&Math.round(y)>=0&&Math.round(y)<this.imageData.width&&Math.round(F)>=0&&Math.round(F)<this.imageData.height&&(i[g]=this.imageData.data[$],i[g+1]=this.imageData.data[$+1],i[g+2]=this.imageData.data[$+2],i[g+3]=this.imageData.data[$+3]),B++}a++}this.offscreenCtx.putImageData(new ImageData(i,e,t),0,0),this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.ctx.drawImage(this.offscreenCanvas,0,0,this.canvas.width,this.canvas.height)}drawGPU(){if(!this.gpu.initialized){console.log("GPU not ready, falling back to CPU"),this.draw();return}const e=this.imageBBox.maxX-this.imageBBox.minX,t=this.imageBBox.maxY-this.imageBBox.minY;this.gpu.updateUniforms({baseNumPoints:this.cameraPoints.length,distortNumPoints:this.cameraLandmarks.filter((i,a)=>a%this.landmarkSkip===0).length,imageWidth:this.imageData.width,imageHeight:this.imageData.height,faceMinY:this.imageBBox.minY,faceMinX:this.imageBBox.minX,faceWidth:e,faceHeight:t}),this.gpu.execute(e,t).then(()=>{this.gpu.readBuffer(this.gpu.faceDataBuffer,e*t*4).then(i=>{const a=new ImageData(i,e,t);this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.offscreenCtx.putImageData(a,0,0),this.ctx.drawImage(this.offscreenCanvas,0,0,this.canvas.width,this.canvas.height),this.gpu.updateFaceDataWithBlurMask(this.blurMask)}).catch(i=>{console.error("Error reading GPU buffer:",i),this.draw()})}).catch(i=>{console.error("Error executing GPU shader:",i),this.draw()})}destroy(){this.gpu&&this.gpu.destroy(),this.canvas&&this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas)}}class St{faceMesh;camera;videoElement;onLandmarksCallback;isInitialized=!1;smoothedLandmarks=null;smoothingFactor=.3;constructor(e,t=.3){this.onLandmarksCallback=e,this.smoothingFactor=Math.max(0,Math.min(1,t)),this.videoElement=document.createElement("video"),this.initializeMediaPipe()}async initializeMediaPipe(){try{const[{FaceMesh:e},{Camera:t}]=await Promise.all([We(()=>import("./face_mesh-C4n09Vz3.js").then(i=>i.f),__vite__mapDeps([0,1])),We(()=>import("./camera_utils-c8ZgCaOI.js").then(i=>i.c),__vite__mapDeps([2,1]))]);this.faceMesh=new e({locateFile:i=>`../node_modules/@mediapipe/face_mesh/${i}`}),this.faceMesh.setOptions({maxNumFaces:1,refineLandmarks:!0}),this.faceMesh.onResults(i=>{if(i.multiFaceLandmarks&&this.onLandmarksCallback){const a=this.regularizeLandmarks(i.multiFaceLandmarks[0]);this.onLandmarksCallback(a)}}),this.camera=new t(this.videoElement,{onFrame:async()=>{await this.faceMesh.send({image:this.videoElement})},width:640,height:480,facingMode:"user"}),this.isInitialized=!0}catch(e){console.error("Failed to initialize MediaPipe:",e)}}regularizeLandmarks(e,t=1){if(!e)return[];const i={x:e.reduce((P,v)=>P+v.x,0)/e.length,y:e.reduce((P,v)=>P+v.y,0)/e.length,z:e.reduce((P,v)=>P+v.z,0)/e.length};let a=e.map(P=>({x:P.x,y:P.y,z:P.z}));a=a.map(P=>({x:P.x-i.x,y:P.y-i.y,z:P.z-i.z}));const B=a[233],f=a[453],o={x:f.x-B.x,y:f.y-B.y,z:f.z-B.z},g=Math.atan2(o.z,o.x);a=a.map(P=>{const v=Math.cos(-g),y=Math.sin(-g);return{x:P.x*v-P.z*y,y:P.y,z:P.x*y+P.z*v}});const A=a.map(P=>P.y),_=2e4/(Math.max(...A)-Math.min(...A));let E=a.map(P=>[P.x*_*t,-P.y*_*t,P.z*_*t]);return E=this.applyTemporalSmoothing(E),E}applyTemporalSmoothing(e){if(!this.smoothedLandmarks)return this.smoothedLandmarks=e.map(i=>[...i]),this.smoothedLandmarks;const t=e.map((i,a)=>{const c=this.smoothedLandmarks[a];return[c[0]+this.smoothingFactor*(i[0]-c[0]),c[1]+this.smoothingFactor*(i[1]-c[1]),c[2]+this.smoothingFactor*(i[2]-c[2])]});return this.smoothedLandmarks=t,t}setSmoothingFactor(e){this.smoothingFactor=Math.max(0,Math.min(1,e))}resetSmoothing(){this.smoothedLandmarks=null}start(){if(!this.isInitialized)throw new Error("MediaPipe components are not initialized. Call initializeMediaPipe() first.");return this.camera.start()}stop(){if(!this.isInitialized)throw new Error("MediaPipe components are not initialized. Call initializeMediaPipe() first.");this.camera.stop()}setOnLandmarksCallback(e){this.onLandmarksCallback=e}}var Ct=fe('<div id=pareidolia style=flex-direction:row;align-items:center;justify-content:center><div style="flex-direction:column;align-items:center;justify-content:center;transform-origin:center center;flex-grow:3;flex-shrink:0"><div style=font-size:16px;pointer-events:none;z-index:1000>Drop an image here</div><canvas id=source></canvas><svg id=landmarks xmlns=http://www.w3.org/2000/svg style=stroke:blue;fill:rgba(255,255,255,0.4)></svg></div><div style=flex-direction:column;align-items:center;justify-content:center;width:300px><h1>Pareidolia</h1><div id=controls><div><!$><!/><svg id=face-svg width=140 height=140></svg></div><h4>Layers</h4><div id=layers><input type=button value=Mask><!$><!/><input type=button value=Basics></div><h4></h4><div></div><input type=button value=Back><input type=button value=Skip><input type=button value=Next><br><input type=button value="Do it!"><h4>Camera</h4><input type=button value=Start><input type=button value=Stop><br><input type=button value="View Points">'),kt=fe("<input type=button>");const J=0,Mt=d=>{let e,t,i,a,c,B,f;const[o,g]=V(!1),[b,A]=V({width:600,height:600}),[C,_]=V(1),[E,P]=V("Upload an Image"),v={points:[]};let y=0,F;const $=1;let ce=null,N="feature",I="basics";const he=n=>{const s=b().width,h=b().height,r=n.filter((G,L)=>L%3===0),u=n.filter((G,L)=>L%3===1),l=Math.min(...r),S=Math.min(...u),x=Math.max(...r),w=Math.max(...u),k=(s-2*J)/(x-l),U=(h-2*J)/(w-S);return n.map((G,L)=>L%3===0?(G-l)*k+J:L%3===1?h-((G-S)*U+J):G)};he(Y.vertices);let D=null;const ue=new St(async n=>{if(n.length>0&&!e){e=n;return}!D||!n||D.updateActiveTargets(n)&&requestAnimationFrame(()=>{try{D.drawGPU(),console.log("GPU")}catch{D.draw(),console.log("CPU fallback")}})});let H=()=>{},j=[],ee=!1;const R=()=>{const n=[],s=[];if(N=="feature"){ge=performance.now();for(const r in v){let u=0;for(const l of v[r]){if(!l){u++;continue}r!="points"&&(v.points[M[r].path[u]]={x:l.x,y:l.y,index:M[r].path[u]}),u++}}}for(const r of v.points)r&&(n.push([r.x,r.y,0]),s.push([Y.vertices[r.index*3],Y.vertices[r.index*3+1],Y.vertices[r.index*3+2]]));console.log(v),n.length>5&&!ee?(N="points",ee=!0,requestAnimationFrame(()=>{ce=new Q(n,s),j=[];for(var r=0;r<Y.vertices.length;r+=3){const u=[Y.vertices[r],Y.vertices[r+1],Y.vertices[r+2]];j.push(ce.inverse(u))}ie(),ee=!1})):H();const h=Object.keys(M)[y];P(h)},Ze=async()=>{H(),D&&D.destroy();const n=new Map;for(const s of v.points)s&&n.set(s.index,[s.x,s.y,0]);D=new wt(n,e,F,$),D.canvas.style.position="absolute",D.canvas.style.top="50%",D.canvas.style.left="50%",D.canvas.style.transform=`translate(${-t.getBoundingClientRect().width/(2*C())}px, ${-t.getBoundingClientRect().height/(2*C())}px) translate(${D.imageBBox.minX}px, ${D.imageBBox.minY}px)`,D.canvas.style.pointerEvents="none",t.after(D.canvas)},Ke=Math.max(...W.filter((n,s)=>s%3===0)),le=Math.min(...W.filter((n,s)=>s%3===0)),Je=Math.max(...W.filter((n,s)=>s%3===1)),de=Math.min(...W.filter((n,s)=>s%3===1)),me=140,te=n=>{const s=W.slice(n*3,n*3+3),h=[];return h.push((s[0]-le)/(Ke-le)*96+22),h.push((s[1]-de)/(Je-de)*112+12),h},O=document.createElementNS("http://www.w3.org/2000/svg","line");O.style.stroke="cyan",O.style.fill="none",O.style.strokeWidth="3";let ge=performance.now();const pe=()=>{if(!f)return;if(y>=3){f.innerHTML="";return}let n=Object.keys(M)[y];console.log(y,n,Object.keys(M));const s=te(M[n].path[0]),h=te(M[n].path[1]),r=(performance.now()-ge)%(1e3*Math.PI),u=.5*(1+Math.cos(r/1e3)),l=[s[0]*u+h[0]*(1-u),s[1]*u+h[1]*(1-u)];O.setAttribute("x1",s[0].toString()),O.setAttribute("y1",s[1].toString()),O.setAttribute("x2",l[0].toString()),O.setAttribute("y2",l[1].toString()),f.appendChild(O),requestAnimationFrame(pe)},ve=n=>{if(!f)return;const s=parseInt(n.getAttribute("index")),h=te(s);console.log(h);const r=document.createElementNS("http://www.w3.org/2000/svg","circle");r.setAttribute("cx",h[0].toString()),r.setAttribute("cy",h[1].toString()),r.setAttribute("r","2"),r.style.stroke="black",r.style.fill="white",f.appendChild(r)},be=()=>{f&&(f.innerHTML="")};let T=null;const Qe=n=>{n.onmousedown=s=>{s.preventDefault(),s.stopPropagation(),T=n,ve(n)},n.onmouseenter=s=>{s.preventDefault(),s.stopPropagation(),ve(n)},n.onmouseleave=s=>{s.preventDefault(),s.stopPropagation(),be()}},ie=(n=!1)=>{if(!a)return;n&&H();const s=[];for(const r in re[I])s.push(...re[I][r].path);console.log(s);for(var h=0;h<j.length;h++){if(!s.includes(h))continue;const r=j[h],u=document.getElementById("point-"+h);if(u)h in v.points&&(u.setAttribute("r",(2/C()).toString()),u.style.stroke="blue",u.style.fill="blue"),u.setAttribute("cx",r[0].toString()),u.setAttribute("cy",r[1].toString());else{const l=document.createElementNS("http://www.w3.org/2000/svg","circle");l.setAttribute("cx",r[0].toString()),l.setAttribute("cy",r[1].toString()),l.setAttribute("id","point-"+h),l.setAttribute("index",h.toString()),l.style.stroke="red",l.style.fill="red",l.setAttribute("r",(.5/C()).toString()),h in v.points&&(l.setAttribute("r",(2/C()).toString()),l.style.stroke="blue",l.style.fill="blue",l.style.strokeWidth="1"),Qe(l),a.appendChild(l)}}},et=(n,s)=>{const r=window.innerHeight*.8;return Math.min(r/s,1)},tt=n=>{n.preventDefault(),n.stopPropagation()},it=n=>{n.preventDefault(),n.stopPropagation();const s=n.dataTransfer?.files;if(!s||s.length===0)return;const h=s[0];if(!h.type.startsWith("image/")){alert("Please drop an image file");return}const r=new FileReader;r.onload=u=>{const l=new Image;l.onload=()=>{const x=Math.min(1,640/l.width,640/l.height),w=l.width*x,k=l.height*x;A({width:w,height:k});const U=et(w,k);_(U),t&&(t.width=w,t.height=k,i=t.getContext("2d"),i?.drawImage(l,0,0,w,k)),a&&(a.setAttribute("width",w.toString()),a.setAttribute("height",k.toString())),F=i.getImageData(0,0,w,k),g(!0),he(Y.vertices),R(),pe()},l.src=u.target?.result},r.readAsDataURL(h)};return ht(()=>{if(!t||!a||(i=t.getContext("2d"),!o()))return;let n=!1,s={x:0,y:0};const h=document.createElementNS("http://www.w3.org/2000/svg","circle");h.setAttribute("cx",s.x.toString()),h.setAttribute("cy",s.y.toString()),h.setAttribute("r",(5/C()).toString()),h.style.stroke="red",h.style.fill="red";const r=document.createElementNS("http://www.w3.org/2000/svg","line");r.setAttribute("x1",s.x.toString()),r.setAttribute("y1",s.y.toString()),r.setAttribute("x2",s.x.toString()),r.setAttribute("y2",s.y.toString()),r.style.stroke="red",r.style.fill="red";const u=document.createElementNS("http://www.w3.org/2000/svg","path");u.setAttribute("d",`M ${s.x} ${s.y} L ${s.x} ${s.y}`),u.style.stroke="red",u.style.fill="rgba(255,0,0,0.2)";const l=S=>{const x=a.getBoundingClientRect(),w=(S.clientX-x.left)/C(),k=(S.clientY-x.top)/C();return{x:w,y:k}};H=()=>{h.remove(),r.remove(),u.remove()},a.onmousedown=S=>{if(y==null||T||N=="points")return;const x=Object.keys(M)[y];S.preventDefault(),S.stopPropagation();const{x:w,y:k}=l(S);n=!0,s={x:w,y:k},v[x]=[],M[x].path.length==1?(h.setAttribute("cx",w.toString()),h.setAttribute("cy",k.toString()),a.appendChild(h)):M[x].path.length==2?(v[x].push(s),r.setAttribute("x1",s.x.toString()),r.setAttribute("y1",s.y.toString()),r.setAttribute("x2",s.x.toString()),r.setAttribute("y2",s.y.toString()),a.appendChild(r)):(v[x].push(s),u.setAttribute("d","M "+v[x].map((U,X)=>`${U.x} ${U.y}`).join(" L ")),a.appendChild(u))},a.onmousemove=S=>{if(y==null)return;if(T){S.preventDefault(),S.stopPropagation();const w=a.getBoundingClientRect(),k=(S.clientX-w.left)/C(),U=(S.clientY-w.top)/C();T.setAttribute("cx",k.toString()),T.setAttribute("cy",U.toString());const X=parseInt(T.getAttribute("index"));v.points[X]={x:k,y:U,index:parseInt(T.getAttribute("index"))},R();return}if(N=="points")return;const x=Object.keys(M)[y];if(S.preventDefault(),S.stopPropagation(),n){const{x:w,y:k}=l(S);M[x].path.length==1?(h.setAttribute("cx",w.toString()),h.setAttribute("cy",k.toString())):M[x].path.length==2?(r.setAttribute("x2",w.toString()),r.setAttribute("y2",k.toString())):(v[x].push({x:w,y:k}),u.setAttribute("d","M "+v[x].map((U,X)=>`${U.x} ${U.y}`).join(" L ")))}},a.onmouseup=S=>{if(y==null)return;if(T||N=="points"){S.preventDefault(),S.stopPropagation(),T=null,be();return}const x=Object.keys(M)[y];S.preventDefault(),S.stopPropagation(),n=!1;const{x:w,y:k}=l(S);M[x].path.length==1?v[x].push(s):M[x].path.length==2?v[x].push({x:w,y:k}):(v[x].push({x:w,y:k}),v[x].push({x:s.x,y:s.y}),u.setAttribute("d","M "+v[x].map((U,X)=>`${U.x} ${U.y}`).join(" L "))),y++,y=Math.min(y,Object.keys(M).length),I=="basics"&&y>2&&(I="silhouette"),R(),H()}}),(()=>{var n=ne(Ct),s=n.firstChild,h=s.firstChild,r=h.nextSibling,u=r.nextSibling,l=s.nextSibling,S=l.firstChild,x=S.nextSibling,w=x.firstChild,k=w.firstChild,[U,X]=Re(k.nextSibling),G=U.nextSibling,L=w.nextSibling,se=L.nextSibling,Pe=se.firstChild,st=Pe.nextSibling,[ye,at]=Re(st.nextSibling),rt=ye.nextSibling,xe=se.nextSibling,Be=xe.nextSibling,we=Be.nextSibling,Se=we.nextSibling,Ce=Se.nextSibling,nt=Ce.nextSibling,ke=nt.nextSibling,ot=ke.nextSibling,Me=ot.nextSibling,Ue=Me.nextSibling,ft=Ue.nextSibling,ct=ft.nextSibling;n.addEventListener("drop",it),n.addEventListener("dragover",tt);var De=c;typeof De=="function"?Z(De,n):c=n,p(n,"position","relative"),p(n,"display","flex"),p(n,"border","2px dashed #ccc"),p(n,"padding","10px"),p(n,"width","100vw"),p(n,"height","100vh"),p(n,"background","rgba(255,0,0,.1)"),p(s,"position","relative"),p(s,"display","flex"),p(h,"position","absolute"),p(h,"top","50%"),p(h,"left","50%"),p(h,"transform","translate(-50%, -50%)"),p(h,"color","#999"),p(h,"background","white");var Ae=t;typeof Ae=="function"?Z(Ae,r):t=r,p(r,"display","block");var Ge=a;typeof Ge=="function"?Z(Ge,u):a=u,p(u,"position","absolute"),p(u,"top","50%"),p(u,"left","50%"),p(u,"transform","translate(-50%, -50%)"),p(u,"filter","invert(1)"),p(l,"display","flex"),p(w,"position","relative"),q(w,oe(mt,{id:"face",ref(m){var z=B;typeof z=="function"?z(m):B=m},width:me,height:me}),U,X);var ze=f;return typeof ze=="function"?Z(ze,G):f=G,p(G,"position","absolute"),p(G,"top","50%"),p(G,"left","50%"),p(G,"transform","translate(-50%, -50%)"),Pe.$$click=()=>{I="mask"},q(se,()=>Object.keys(re).map(m=>(()=>{var z=ne(kt);return z.$$click=()=>{I=m,ie(!0)},ut(z,"value",m),Ne(),z})()),ye,at),rt.$$click=()=>{I="basics"},q(xe,(()=>{var m=He(()=>E()in M);return()=>m()?M[E()].name:"Upload an Image"})()),q(Be,(()=>{var m=He(()=>E()in M);return()=>m()?M[E()].description:"Drag and drop an image to get started."})()),we.$$click=()=>{y=Math.max(0,y-1),R()},Se.$$click=()=>{v[E()]=[],y++,y>=Object.keys(M).length&&(y=0),R()},Ce.$$click=()=>{y++,y>=Object.keys(M).length&&(y=0),R()},ke.$$click=()=>{Ze()},Me.$$click=()=>{ue.start().catch(m=>{console.error("Failed to start camera:",m)})},Ue.$$click=()=>{ue.stop()},ct.$$click=m=>{const z=m.target;a.children.length>0?(a.innerHTML="",z.value="View Points"):(ie(),z.value="Hide Points")},lt(m=>{var z=`scale(${C()})`,_e=o()?b().width*C()+"px":"auto",Ee=o()?b().height*C()+"px":"auto",Te=o()?"none":"block",Ye=b().width,$e=b().height,Oe=o()?`${-.5/C()}em ${.5/C()}em 0 rgba(0,0,0,.5), ${-1/C()}em ${1/C()}em 0 gray`:"none",Le=b().width,Ie=b().height,Xe=o()?"auto":"none",Fe=`${5/C()}px`;return z!==m.e&&p(s,"transform",m.e=z),_e!==m.t&&p(s,"width",m.t=_e),Ee!==m.a&&p(s,"height",m.a=Ee),Te!==m.o&&p(h,"display",m.o=Te),Ye!==m.i&&K(r,"width",m.i=Ye),$e!==m.n&&K(r,"height",m.n=$e),Oe!==m.s&&p(r,"box-shadow",m.s=Oe),Le!==m.h&&K(u,"width",m.h=Le),Ie!==m.r&&K(u,"height",m.r=Ie),Xe!==m.d&&p(u,"pointer-events",m.d=Xe),Fe!==m.l&&p(u,"stroke-width",m.l=Fe),m},{e:void 0,t:void 0,a:void 0,o:void 0,i:void 0,n:void 0,s:void 0,h:void 0,r:void 0,d:void 0,l:void 0}),Ne(),n})()};dt(["click"]);var Ut=fe("<div>");const Et=()=>(new gt,(()=>{var d=ne(Ut);return p(d,"width","100vw"),p(d,"height","100vh"),q(d,oe(pt,{get children(){return oe(Mt,{})}})),d})());export{Et as default};

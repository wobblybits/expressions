import{m,N as b,c as x,a as I,E as y,f as W,h as N,g,t as p,i as _,d as C,r as S,e as A,s as $,C as F}from"./client-CA75qaa4.js";import{B as O,T,P as j}from"./TPS-C8mR9rjN.js";class H extends O{emotionModel;emotionTransforms;modelPoints;allPoints;modelBBox;emotionTPS;baseEmotionLevels;skipLandmarks;constructor(e,t,a){const o=a,i=t,c=new ImageData(1,1),h=[];for(let s=0;s<m.length;s+=3)h.push([m[s],-m[s+1],m[s+2]]);super(e,c,1,h),this.emotionModel=o,this.skipLandmarks=4,this.modelPoints=[],this.allPoints=[],this.baseEmotionLevels={...b,...i};const n=a.calculateCompositeEmotion(this.baseEmotionLevels);for(const[s]of e)this.modelPoints.push([n[s*3]+m[s*3],n[s*3+1]-m[s*3+1],n[s*3+2]+m[s*3+2]]);for(let s=0;s<m.length;s+=3*this.skipLandmarks)this.allPoints.push([n[s]+m[s],n[s+1]-m[s+1],n[s+2]+m[s+2]]);this.emotionTransforms=[],this.modelBBox=this.getBBox(this.silhouetteHull),Object.keys(b).forEach(s=>{this.emotionTransforms[s]=this.getEmotionTransform({[s]:100})}),this.setupTPS(),console.log("emotionTransforms",this.emotionTransforms)}setupTPS(){this.baseTPS=new T(this.modelPoints,this.imagePoints),this.emotionTPS=new T(this.allPoints,this.allPoints),this.nilpotentTPS=new T(this.imagePoints,this.imagePoints)}getSilhouettePoints(){const e=[];for(let t=0;t<m.length;t+=3)e.push([m[t],-m[t+1],m[t+2]]);return e}getTransformationPoints(){return{base:this.modelPoints,distort:this.allPoints}}updateActiveTargets(e){const t=[],a=this.emotionModel.calculateCompositeEmotion(e);for(var o=0;o<a.length;o+=3*this.skipLandmarks)t.push([a[o]+m[o],a[o+1]-m[o+1],a[o+2]+m[o+2]]);return this.emotionTPS=new T(this.allPoints,t),this.gpu.initialized&&this.gpu.updateCombinedCoeffs(this.gpu.model2distortCoeffsBuffer,this.emotionTPS.inverseParameters.Xc,this.emotionTPS.inverseParameters.Yc),!0}transformXYWithEmotion(e,t,a){let o=t*100,i=a*100,c=100;for(const h in e){if(e[h]==0)continue;const n=this.emotionTransforms[h].get(`${t},${a}`);o+=e[h]*n[0],i+=e[h]*n[1],c+=e[h]}return[o/c,i/c]}transformXY(e,t){return[e,t,0]}async transformGPU(e){if(!this.gpu.initialized)return console.log("GPU not ready for ImageTPS, falling back to CPU"),null;try{this.updateActiveTargets(e);const t=this.imageBBox.maxX-this.imageBBox.minX,a=this.imageBBox.maxY-this.imageBBox.minY;this.updateGPUUniforms(),await this.gpu.execute(t,a);const o=await this.gpu.readBuffer(this.gpu.faceDataBuffer,t*a*4),i=new ImageData(o,t,a);return this.gpu.updateFaceDataWithBlurMask(this.blurMask),i}catch(t){return console.error("Error executing GPU transformation for ImageTPS:",t),null}}async drawGPUWithEmotion(e,t){const a=await this.transformGPU(e);a?(this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.offscreenCtx.putImageData(a,0,0),this.ctx.drawImage(this.offscreenCanvas,0,0,this.canvas.width,this.canvas.height),console.log("GPU rendering")):(this.drawCPU(e,t),console.log("CPU fallback"))}async drawGPU(){return Promise.resolve()}drawCPU(e,t){const a={...e};for(var o in this.baseEmotionLevels)a[o]-=this.baseEmotionLevels[o];const i=new Uint8ClampedArray(this.canvas.width*this.canvas.height*4).fill(0),c=t.width;for(var h=0;h<this.canvas.height;h++)for(var n=0;n<this.canvas.width;n++){if(this.mask[h*this.canvas.width+n]==0)continue;const s=this.transformXYWithEmotion(a,n+this.imageBBox.minX,h+this.imageBBox.minY),d=(h*this.canvas.width+n)*4,f=(Math.round(s[1])*c+Math.round(s[0]))*4;f>=0&&f<t.data.length-3&&(i[d]=t.data[f],i[d+1]=t.data[f+1],i[d+2]=t.data[f+2],i[d+3]=t.data[f+3])}this.ctx.putImageData(new ImageData(i,this.canvas.width,this.canvas.height),0,0)}getEmotionTransform(e){let t=[];const a=this.emotionModel.calculateCompositeEmotion(e);for(const[i,c]of this.imageLandmarks)t.push([a[i*3]+m[i*3],a[i*3+1]-m[i*3+1],a[i*3+2]+m[i*3+2]]);const o=new T(this.modelPoints,t);return this.precomputeTransformationMaps(o)}precomputeTransformationMaps(e){const t=new Map;for(let a=this.imageBBox.minY;a<this.imageBBox.maxY;a++)for(let o=this.imageBBox.minX;o<this.imageBBox.maxX;o++){const i=`${o},${a}`,c=this.baseTPS.forward(e.forward(this.baseTPS.inverse([o,a,0])));t.set(i,c)}return t}getBBox(e){return{minX:Math.floor(Math.min(...e.map(t=>t[0]))),maxX:Math.ceil(Math.max(...e.map(t=>t[0]))),minY:Math.floor(Math.min(...e.map(t=>t[1]))),maxY:Math.ceil(Math.max(...e.map(t=>t[1]))),minZ:Math.floor(Math.min(...e.map(t=>t[2]))),maxZ:Math.ceil(Math.max(...e.map(t=>t[2])))}}}var z=p("<h4>"),R=p("<div>Drag and drop an image to get started."),Z=p("<input type=button value=Back>"),q=p("<input type=button value=Skip>"),J=p("<input type=button value=Next>"),K=p("<br>"),Q=p('<input type=button value="Do it!">');const V=E=>{const{emotionModel:e}=E,[t,a]=x(b),[o,i]=x(b),[c,h]=x(!1),[n,s]=x(null),[d,f]=x(null),X=(l,r)=>{},Y=l=>{f(l)},D=async l=>{if(c()||!n())return;a(l);const r={...l};for(var P in o())r[P]-=o()[P];h(!0);try{await n().drawGPUWithEmotion(r,d())}catch(L){console.error("GPU rendering failed, using CPU fallback:",L);const u=n().getCanvas(),B=new Uint8ClampedArray(u.width*u.height*4).fill(0),G=u.width;for(var v=0;v<u.height;v++)for(var w=0;w<u.width;w++){if(n().getMask()[v*u.width+w]==0)continue;const U=n().transformXYWithEmotion(r,w+n().getImageBBox().minX,v+n().getImageBBox().minY),k=(v*u.width+w)*4,M=(Math.round(U[1])*G+Math.round(U[0]))*4;B[k]=d().data[M],B[k+1]=d().data[M+1],B[k+2]=d().data[M+2],B[k+3]=d().data[M+3]}n().getCanvas().getContext("2d")?.putImageData(new ImageData(B,u.width,u.height),0,0)}finally{h(!1)}};return I(j,{controls:{render:l=>I(W,N({title:"Pareidolia",emotionModel:e,callback:D},l,{get children(){return[(()=>{var r=g(z);return _(r,()=>l.featureName),r})(),g(R),(()=>{var r=g(Z);return C(r,"click",l.onBack),S(),r})(),(()=>{var r=g(q);return C(r,"click",l.onSkip),S(),r})(),(()=>{var r=g(J);return C(r,"click",l.onNext),S(),r})(),g(K),(()=>{var r=g(Q);return C(r,"click",l.onProcess),S(),r})()]}}))},tpsConfig:{create:(l,r)=>{const P=new H(l,t(),new y);return s(P),P},update:(l,r)=>{},destroy:l=>{l.destroy(),s(null)}},onFeatureComplete:X,onImageProcessed:Y})};A(["click"]);var tt=p("<div>");const st=()=>{const E=new y;return(()=>{var e=g(tt);return $(e,"width","100vw"),$(e,"height","100vh"),_(e,I(F,{get children(){return I(V,{emotionModel:E})}})),e})()};export{st as default};

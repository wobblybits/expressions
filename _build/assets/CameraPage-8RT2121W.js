const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/face_mesh-C4n09Vz3.js","assets/_commonjsHelpers-Cpj98o6Y.js","assets/camera_utils-c8ZgCaOI.js"])))=>i.map(i=>d[i]);
import{_ as X,c as g,a as S,g as it,t as at,b as nt,s as p,i as R,F as st,d as M,r as rt,u as ot,e as lt,E as ct,C as mt}from"./client-CA75qaa4.js";import{B as ht,T as D,P as dt}from"./TPS-C8mR9rjN.js";class N extends ht{cameraLandmarks;cameraPoints;cameraBBox;landmarkSkip;inverseMap;constructor(t,e,i,a=2){const r=e.map(o=>[o[0],o[1]]);super(t,i,a,r),this.cameraLandmarks=e,this.landmarkSkip=2,this.cameraPoints=[];for(const[o,m]of t)o<this.cameraLandmarks.length?this.cameraPoints.push([this.cameraLandmarks[o][0],this.cameraLandmarks[o][1]]):console.log("Image landmark index out of bounds:",o);this.cameraBBox=this.getBBox(this.silhouetteHull),this.inverseMap=this.precomputeTransformationMap(this.baseTPS),this.setupTPS(),this.initializeGPU().then(()=>{console.log("CameraTPS GPU initialized successfully")}).catch(o=>{console.error("Failed to initialize CameraTPS GPU:",o)})}setupTPS(){this.baseTPS=new D(this.cameraPoints,this.imagePoints),this.nilpotentTPS=new D(this.cameraLandmarks.filter((t,e)=>e%this.landmarkSkip===0).map(t=>t.slice(0,2)),this.cameraLandmarks.filter((t,e)=>e%this.landmarkSkip===0).map(t=>t.slice(0,2))),this.activeTPS=this.nilpotentTPS}getSilhouettePoints(){return[]}getTransformationPoints(){return{base:this.cameraPoints,distort:this.cameraLandmarks.filter((t,e)=>e%this.landmarkSkip===0).map(t=>t.slice(0,2))}}updateActiveTargets(t){const e=this.activeTPS.updateInverseParameters(t.filter((i,a)=>a%this.landmarkSkip===0).map(i=>i.slice(0,2)));return e&&this.gpu.initialized&&(this.gpu.updateBuffer(this.gpu.distortPointsBuffer,new Float32Array(t.filter((i,a)=>a%this.landmarkSkip===0).map(i=>i.slice(0,2)).flat())),this.gpu.updateCombinedCoeffs(this.gpu.model2distortCoeffsBuffer,new Float32Array(e.Xc),new Float32Array(e.Yc))),!0}transformXY(t,e){const i=this.inverseMap[(e-this.imageBBox.minY)*(this.imageBBox.maxX-this.imageBBox.minX)+t-this.imageBBox.minX];return this.baseTPS.forward(this.activeTPS.inverse(i))}precomputeTransformationMap(t){const e=[];for(let i=this.imageBBox.minY;i<this.imageBBox.maxY;i++)for(let a=this.imageBBox.minX;a<this.imageBBox.maxX;a++){const r=t.inverse([a,i,0]);e.push(r)}return e}getBBox(t){return{minX:Math.floor(Math.min(...t.map(e=>e[0]))),maxX:Math.ceil(Math.max(...t.map(e=>e[0]))),minY:Math.floor(Math.min(...t.map(e=>e[1]))),maxY:Math.ceil(Math.max(...t.map(e=>e[1]))),minZ:Math.floor(Math.min(...t.map(e=>e[2]))),maxZ:Math.ceil(Math.max(...t.map(e=>e[2])))}}}class ut{faceMesh;camera;videoElement;onLandmarksCallback;isInitialized=!1;smoothedLandmarks=null;smoothingFactor=.3;constructor(t,e=.3){this.onLandmarksCallback=t,this.smoothingFactor=Math.max(0,Math.min(1,e)),this.videoElement=document.createElement("video"),this.initializeMediaPipe()}async initializeMediaPipe(){try{const[{FaceMesh:t},{Camera:e}]=await Promise.all([X(()=>import("./face_mesh-C4n09Vz3.js").then(i=>i.f),__vite__mapDeps([0,1])),X(()=>import("./camera_utils-c8ZgCaOI.js").then(i=>i.c),__vite__mapDeps([2,1]))]);this.faceMesh=new t({locateFile:i=>`../node_modules/@mediapipe/face_mesh/${i}`}),this.faceMesh.setOptions({maxNumFaces:1,refineLandmarks:!0}),this.faceMesh.onResults(i=>{if(i.multiFaceLandmarks&&this.onLandmarksCallback){const a=this.regularizeLandmarks(i.multiFaceLandmarks[0]);this.onLandmarksCallback(a)}}),this.camera=new e(this.videoElement,{onFrame:async()=>{await this.faceMesh.send({image:this.videoElement})},width:640,height:480,facingMode:"user"}),this.isInitialized=!0}catch(t){console.error("Failed to initialize MediaPipe:",t)}}regularizeLandmarks(t,e=1){if(!t)return[];const i={x:t.reduce((n,c)=>n+c.x,0)/t.length,y:t.reduce((n,c)=>n+c.y,0)/t.length,z:t.reduce((n,c)=>n+c.z,0)/t.length};let a=t.map(n=>({x:n.x,y:n.y,z:n.z}));a=a.map(n=>({x:n.x-i.x,y:n.y-i.y,z:n.z-i.z}));const o=a[233],m=a[453],k={x:m.x-o.x,y:m.y-o.y,z:m.z-o.z},v=Math.atan2(k.z,k.x);a=a.map(n=>{const c=Math.cos(-v),f=Math.sin(-v);return{x:n.x*c-n.z*f,y:n.y,z:n.x*f+n.z*c}});const _=a.map(n=>n.y),h=2e4/(Math.max(..._)-Math.min(..._));let d=a.map(n=>[n.x*h*e,-n.y*h*e,n.z*h*e]);return d=this.applyTemporalSmoothing(d),d}applyTemporalSmoothing(t){if(!this.smoothedLandmarks)return this.smoothedLandmarks=t.map(i=>[...i]),this.smoothedLandmarks;const e=t.map((i,a)=>{const r=this.smoothedLandmarks[a];return[r[0]+this.smoothingFactor*(i[0]-r[0]),r[1]+this.smoothingFactor*(i[1]-r[1]),r[2]+this.smoothingFactor*(i[2]-r[2])]});return this.smoothedLandmarks=e,e}setSmoothingFactor(t){this.smoothingFactor=Math.max(0,Math.min(1,t))}resetSmoothing(){this.smoothedLandmarks=null}start(){if(!this.isInitialized)throw new Error("MediaPipe components are not initialized. Call initializeMediaPipe() first.");return this.camera.start()}stop(){if(!this.isInitialized)throw new Error("MediaPipe components are not initialized. Call initializeMediaPipe() first.");this.camera.stop()}setOnLandmarksCallback(t){this.onLandmarksCallback=t}}var pt=at('<div style=flex-direction:column;align-items:center;justify-content:center;width:300px><h1>Pareidolia</h1><div id=controls><div><!$><!/><svg id=face-svg width=140 height=140></svg></div><h4>Layers</h4><div id=layers><input type=button value=Mask><input type=button value=Basics></div><h4></h4><div>Drag and drop an image to get started.</div><input type=button value=Back><input type=button value=Skip><input type=button value=Next><br><input type=button value="Do it!"><h4>Camera</h4><input type=button value=Start><input type=button value=Stop><br><input type=button value="View Points">');const gt=b=>{let t,e,i;const[a,r]=g(null),[o,m]=g(null),[k,v]=g(!1),[O,_]=g([]),[G,h]=g("basics"),d=1,n=new ut(async s=>{if(s.length>0&&!t){t=s;return}!a()||!s||a().updateActiveTargets(s)&&requestAnimationFrame(()=>{try{a().drawGPU(),console.log("GPU")}catch{a().draw(),console.log("CPU fallback")}})}),c=(s,l)=>{},f=s=>{m(s)},U=()=>{a()&&(a()?.destroy(),r(null));const s=new Map,l=new N(s,t,o(),d);r(l)},V=()=>{};return S(dt,{controls:{render:s=>(()=>{var l=it(pt),x=l.firstChild,H=x.nextSibling,P=H.firstChild,Z=P.firstChild,[$,j]=nt(Z.nextSibling),u=$.nextSibling,q=P.nextSibling,C=q.nextSibling,z=C.firstChild,W=z.nextSibling,B=C.nextSibling,J=B.nextSibling,L=J.nextSibling,T=L.nextSibling,w=T.nextSibling,K=w.nextSibling,F=K.nextSibling,Q=F.nextSibling,E=Q.nextSibling,I=E.nextSibling,tt=I.nextSibling,et=tt.nextSibling;p(l,"display","flex"),p(P,"position","relative"),R(P,S(st,{id:"face",ref(y){var Y=e;typeof Y=="function"?Y(y):e=y},width:140,height:140}),$,j);var A=i;return typeof A=="function"?ot(A,u):i=u,p(u,"position","absolute"),p(u,"top","50%"),p(u,"left","50%"),p(u,"transform","translate(-50%, -50%)"),z.$$click=()=>h("mask"),W.$$click=()=>h("basics"),R(B,()=>s.featureName),M(L,"click",s.onBack),M(T,"click",s.onSkip),M(w,"click",s.onNext),F.$$click=U,E.$$click=()=>{n.start().catch(y=>{console.error("Failed to start camera:",y)})},I.$$click=()=>{n.stop()},et.$$click=V,rt(),l})()},tpsConfig:{create:(s,l)=>{const x=new N(s,t,l,d);return r(x),x},update:(s,l)=>{s.updateActiveTargets(l)},destroy:s=>{s.destroy(),r(null)}},onFeatureComplete:c,onImageProcessed:f})};lt(["click"]);const Pt=()=>(new ct,S(mt,{get children(){return S(gt,{})}}));export{Pt as default};

import{a as b,N as $,g as p,t as v,b as Y,s as _,i as E,c as S,f as F,F as N,h as A,j as O,r as k,k as R,e as W,m,E as j,n as H,d as U,C as z}from"./client-CBWUQPxk.js";import{B as Z,T,P as q}from"./TPS-D0ADRJpB.js";var J=v("<div style=flex-direction:column;align-items:center;justify-content:center;width:300px><h1 class=pixelated-text></h1><div id=controls class=pixelated-border><h4>Expression</h4><!$><!/><!$><!/><input type=button value=Reset><!$><!/>"),K=v("<div id=emotion-sliders style=align-items:center><input type=range min=-100 max=100><span>");const Q=P=>{const[e,t]=b($);return(()=>{var n=p(J),i=n.firstChild,l=i.nextSibling,d=l.firstChild,o=d.nextSibling,[a,s]=Y(o.nextSibling),u=a.nextSibling,[c,L]=Y(u.nextSibling),M=c.nextSibling,D=M.nextSibling,[h,r]=Y(D.nextSibling);return _(n,"display","flex"),E(i,()=>P.title),E(l,S(N,{id:"face",width:140,height:140,get expressionModel(){return new F(P.emotionModel)},emotionLevels:e}),a,s),E(l,S(R,{get each(){return Object.keys($)},children:g=>(()=>{var x=p(K),w=x.firstChild,X=w.nextSibling;return _(x,"display","flex"),_(x,"gap","10px"),w.$$input=f=>{const y={...e(),[g]:parseInt(f.target.value)};t(y),P.callback(y)},E(X,()=>String(g)),A(()=>O(w,"value",e()[g])),k(),x})()}),c,L),M.$$click=()=>{t($),document.querySelectorAll("#emotion-sliders input[type='range']").forEach(g=>{g.value="0"}),P.callback($)},E(l,()=>P.children,h,r),k(),n})()};W(["click","input"]);class V extends Z{emotionModel;emotionTransforms;modelPoints;allPoints;modelBBox;emotionTPS;baseEmotionLevels;skipLandmarks;constructor(e,t,n){const i=n,l=t,d=new ImageData(1,1),o=[];for(let s=0;s<m.length;s+=3)o.push([m[s],-m[s+1],m[s+2]]);super(e,d,1,o),this.emotionModel=i,this.skipLandmarks=4,this.modelPoints=[],this.allPoints=[],this.baseEmotionLevels={...$,...l};const a=n.calculateCompositeEmotion(this.baseEmotionLevels);for(const[s,u]of e){const c=parseInt(s);this.modelPoints.push([a[c*3]+m[c*3],a[c*3+1]-m[c*3+1],a[c*3+2]+m[c*3+2]])}for(let s=0;s<m.length;s+=3*this.skipLandmarks)this.allPoints.push([a[s]+m[s],a[s+1]-m[s+1],a[s+2]+m[s+2]]);this.emotionTransforms=[],this.modelBBox=this.getBBox(this.silhouetteHull),Object.keys($).forEach(s=>{this.emotionTransforms[s]=this.getEmotionTransform({[s]:100})}),this.setupTPS(),console.log("emotionTransforms",this.emotionTransforms)}setupTPS(){this.baseTPS=new T(this.modelPoints,this.imagePoints),this.emotionTPS=new T(this.allPoints,this.allPoints),this.nilpotentTPS=new T(this.imagePoints,this.imagePoints)}getSilhouettePoints(){const e=[];for(let t=0;t<m.length;t+=3)e.push([m[t],-m[t+1],m[t+2]]);return e}getTransformationPoints(){return{base:this.modelPoints,distort:this.allPoints}}updateActiveTargets(e){const t=[],n=this.emotionModel.calculateCompositeEmotion(e);for(var i=0;i<n.length;i+=3*this.skipLandmarks)t.push([n[i]+m[i],n[i+1]-m[i+1],n[i+2]+m[i+2]]);return this.emotionTPS=new T(this.allPoints,t),this.gpu.initialized&&this.gpu.updateCombinedCoeffs(this.gpu.model2distortCoeffsBuffer,this.emotionTPS.inverseParameters.Xc,this.emotionTPS.inverseParameters.Yc),!0}transformXYWithEmotion(e,t,n){let i=t*100,l=n*100,d=100;for(const o in e){if(e[o]==0)continue;const a=this.emotionTransforms[o].get(`${t},${n}`);i+=e[o]*a[0],l+=e[o]*a[1],d+=e[o]}return[i/d,l/d]}transformXY(e,t){return[e,t,0]}async transformGPU(e){if(!this.gpu.initialized)return console.log("GPU not ready for ImageTPS, falling back to CPU"),null;try{this.updateActiveTargets(e);const t=this.imageBBox.maxX-this.imageBBox.minX,n=this.imageBBox.maxY-this.imageBBox.minY;this.updateGPUUniforms(),await this.gpu.execute(t,n);const i=await this.gpu.readBuffer(this.gpu.faceDataBuffer,t*n*4),l=new ImageData(i,t,n);return this.gpu.updateFaceDataWithBlurMask(this.blurMask),l}catch(t){return console.error("Error executing GPU transformation for ImageTPS:",t),null}}async drawGPUWithEmotion(e,t){const n=await this.transformGPU(e);n?(this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.offscreenCtx.putImageData(n,0,0),this.ctx.drawImage(this.offscreenCanvas,0,0,this.canvas.width,this.canvas.height),console.log("GPU rendering")):(this.drawCPU(e,t),console.log("CPU fallback"))}async drawGPU(){return Promise.resolve()}drawCPU(e,t){const n={...e};for(var i in this.baseEmotionLevels)n[i]-=this.baseEmotionLevels[i];const l=new Uint8ClampedArray(this.canvas.width*this.canvas.height*4).fill(0),d=t.width;for(var o=0;o<this.canvas.height;o++)for(var a=0;a<this.canvas.width;a++){if(this.mask[o*this.canvas.width+a]==0)continue;const s=this.transformXYWithEmotion(n,a+this.imageBBox.minX,o+this.imageBBox.minY),u=(o*this.canvas.width+a)*4,c=(Math.round(s[1])*d+Math.round(s[0]))*4;c>=0&&c<t.data.length-3&&(l[u]=t.data[c],l[u+1]=t.data[c+1],l[u+2]=t.data[c+2],l[u+3]=t.data[c+3])}this.ctx.putImageData(new ImageData(l,this.canvas.width,this.canvas.height),0,0)}getEmotionTransform(e){let t=[];const n=this.emotionModel.calculateCompositeEmotion(e);for(const[l,d]of this.imageLandmarks){const o=parseInt(l);t.push([n[o*3]+m[o*3],n[o*3+1]-m[o*3+1],n[o*3+2]+m[o*3+2]])}const i=new T(this.modelPoints,t);return this.precomputeTransformationMaps(i)}precomputeTransformationMaps(e){const t=new Map;for(let n=this.imageBBox.minY;n<this.imageBBox.maxY;n++)for(let i=this.imageBBox.minX;i<this.imageBBox.maxX;i++){const l=`${i},${n}`,d=this.baseTPS.forward(e.forward(this.baseTPS.inverse([i,n,0])));t.set(l,d)}return t}getBBox(e){return{minX:Math.floor(Math.min(...e.map(t=>t[0]))),maxX:Math.ceil(Math.max(...e.map(t=>t[0]))),minY:Math.floor(Math.min(...e.map(t=>t[1]))),maxY:Math.ceil(Math.max(...e.map(t=>t[1]))),minZ:Math.floor(Math.min(...e.map(t=>t[2]))),maxZ:Math.ceil(Math.max(...e.map(t=>t[2])))}}}var tt=v("<h4>"),et=v("<div>Drag and drop an image to get started."),nt=v("<input type=button value=Back>"),it=v("<input type=button value=Skip>"),at=v("<input type=button value=Next>"),st=v("<br>"),ot=v('<input type=button value="Do it!">');const rt=P=>{const{emotionModel:e}=P,[t,n]=b($),[i,l]=b($),[d,o]=b(!1),[a,s]=b(null),[u,c]=b(null),L=(h,r)=>{},M=h=>{c(h)},D=async h=>{if(d()||!a())return;n(h);const r={...h};for(var g in i())r[g]-=i()[g];o(!0);try{await a().drawGPUWithEmotion(r,u())}catch(X){console.error("GPU rendering failed, using CPU fallback:",X);const f=a().getCanvas(),B=new Uint8ClampedArray(f.width*f.height*4).fill(0),y=f.width;for(var x=0;x<f.height;x++)for(var w=0;w<f.width;w++){if(a().getMask()[x*f.width+w]==0)continue;const G=a().transformXYWithEmotion(r,w+a().getImageBBox().minX,x+a().getImageBBox().minY),C=(x*f.width+w)*4,I=(Math.round(G[1])*y+Math.round(G[0]))*4;B[C]=u().data[I],B[C+1]=u().data[I+1],B[C+2]=u().data[I+2],B[C+3]=u().data[I+3]}a().getCanvas().getContext("2d")?.putImageData(new ImageData(B,f.width,f.height),0,0)}finally{o(!1)}};return S(q,{controls:{render:h=>S(Q,H({title:"Pareidolia",emotionModel:e,callback:D},h,{get children(){return[(()=>{var r=p(tt);return E(r,()=>h.featureName),r})(),p(et),(()=>{var r=p(nt);return U(r,"click",h.onBack),k(),r})(),(()=>{var r=p(it);return U(r,"click",h.onSkip),k(),r})(),(()=>{var r=p(at);return U(r,"click",h.onNext),k(),r})(),p(st),(()=>{var r=p(ot);return U(r,"click",h.onProcess),k(),r})()]}}))},tpsConfig:{create:(h,r)=>{const g=new V(h,t(),new j);return s(g),g},update:(h,r)=>{},destroy:h=>{h.destroy(),s(null)}},onFeatureComplete:L,onImageProcessed:M})};W(["click"]);var lt=v("<div>"),mt=v('<div class="flex items-center justify-center h-full"><div class=text-center><p class=text-lg>Loading pareidolia...');const dt=()=>{const P=new j;return(()=>{var e=p(lt);return _(e,"width","100vw"),_(e,"height","100vh"),E(e,S(z,{get fallback(){return p(mt)},get children(){return S(rt,{emotionModel:P})}})),e})()};export{dt as default};

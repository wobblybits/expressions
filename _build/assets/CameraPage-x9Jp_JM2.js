const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/face_mesh-C4n09Vz3.js","assets/_commonjsHelpers-Cpj98o6Y.js","assets/camera_utils-c8ZgCaOI.js"])))=>i.map(i=>d[i]);
import{_ as R,a as f,c as S,g as O,t as G,b as nt,s as h,i as $,F as st,d as b,r as rt,u as ot,e as lt,E as ct,C as ht}from"./client-CBWUQPxk.js";import{B as mt,T as D,P as dt}from"./TPS-D0ADRJpB.js";class N extends mt{cameraLandmarks;cameraPoints;cameraBBox;landmarkSkip;inverseMap;constructor(t,e,i,a=2){const r=e.map(o=>[o[0],o[1]]);super(t,i,a,r),this.cameraLandmarks=e,this.landmarkSkip=2,this.cameraPoints=[];for(const[o,d]of t)o<this.cameraLandmarks.length?this.cameraPoints.push([this.cameraLandmarks[o][0],this.cameraLandmarks[o][1]]):console.log("Image landmark index out of bounds:",o);this.cameraBBox=this.getBBox(this.silhouetteHull),this.inverseMap=this.precomputeTransformationMap(this.baseTPS),this.setupTPS(),this.initializeGPU().then(()=>{console.log("CameraTPS GPU initialized successfully")}).catch(o=>{console.error("Failed to initialize CameraTPS GPU:",o)})}setupTPS(){this.baseTPS=new D(this.cameraPoints,this.imagePoints),this.nilpotentTPS=new D(this.cameraLandmarks.filter((t,e)=>e%this.landmarkSkip===0).map(t=>t.slice(0,2)),this.cameraLandmarks.filter((t,e)=>e%this.landmarkSkip===0).map(t=>t.slice(0,2))),this.activeTPS=this.nilpotentTPS}getSilhouettePoints(){return[]}getTransformationPoints(){return{base:this.cameraPoints,distort:this.cameraLandmarks.filter((t,e)=>e%this.landmarkSkip===0).map(t=>t.slice(0,2))}}updateActiveTargets(t){const e=this.activeTPS.updateInverseParameters(t.filter((i,a)=>a%this.landmarkSkip===0).map(i=>i.slice(0,2)));return e&&this.gpu.initialized&&(this.gpu.updateBuffer(this.gpu.distortPointsBuffer,new Float32Array(t.filter((i,a)=>a%this.landmarkSkip===0).map(i=>i.slice(0,2)).flat())),this.gpu.updateCombinedCoeffs(this.gpu.model2distortCoeffsBuffer,new Float32Array(e.Xc),new Float32Array(e.Yc))),!0}transformXY(t,e){const i=this.inverseMap[(e-this.imageBBox.minY)*(this.imageBBox.maxX-this.imageBBox.minX)+t-this.imageBBox.minX];return this.baseTPS.forward(this.activeTPS.inverse(i))}precomputeTransformationMap(t){const e=[];for(let i=this.imageBBox.minY;i<this.imageBBox.maxY;i++)for(let a=this.imageBBox.minX;a<this.imageBBox.maxX;a++){const r=t.inverse([a,i,0]);e.push(r)}return e}getBBox(t){return{minX:Math.floor(Math.min(...t.map(e=>e[0]))),maxX:Math.ceil(Math.max(...t.map(e=>e[0]))),minY:Math.floor(Math.min(...t.map(e=>e[1]))),maxY:Math.ceil(Math.max(...t.map(e=>e[1]))),minZ:Math.floor(Math.min(...t.map(e=>e[2]))),maxZ:Math.ceil(Math.max(...t.map(e=>e[2])))}}}class ut{faceMesh;camera;videoElement;onLandmarksCallback;isInitialized=!1;smoothedLandmarks=null;smoothingFactor=.3;constructor(t,e=.3){this.onLandmarksCallback=t,this.smoothingFactor=Math.max(0,Math.min(1,e)),this.videoElement=document.createElement("video"),this.initializeMediaPipe()}async initializeMediaPipe(){try{const[{FaceMesh:t},{Camera:e}]=await Promise.all([R(()=>import("./face_mesh-C4n09Vz3.js").then(i=>i.f),__vite__mapDeps([0,1])),R(()=>import("./camera_utils-c8ZgCaOI.js").then(i=>i.c),__vite__mapDeps([2,1]))]);this.faceMesh=new t({locateFile:i=>`../node_modules/@mediapipe/face_mesh/${i}`}),this.faceMesh.setOptions({maxNumFaces:1,refineLandmarks:!0}),this.faceMesh.onResults(i=>{if(i.multiFaceLandmarks&&this.onLandmarksCallback){const a=this.regularizeLandmarks(i.multiFaceLandmarks[0]);this.onLandmarksCallback(a)}}),this.camera=new e(this.videoElement,{onFrame:async()=>{await this.faceMesh.send({image:this.videoElement})},width:640,height:480,facingMode:"user"}),this.isInitialized=!0}catch(t){console.error("Failed to initialize MediaPipe:",t)}}regularizeLandmarks(t,e=1){if(!t)return[];const i={x:t.reduce((n,c)=>n+c.x,0)/t.length,y:t.reduce((n,c)=>n+c.y,0)/t.length,z:t.reduce((n,c)=>n+c.z,0)/t.length};let a=t.map(n=>({x:n.x,y:n.y,z:n.z}));a=a.map(n=>({x:n.x-i.x,y:n.y-i.y,z:n.z-i.z}));const o=a[233],d=a[453],k={x:d.x-o.x,y:d.y-o.y,z:d.z-o.z},_=Math.atan2(k.z,k.x);a=a.map(n=>{const c=Math.cos(-_),x=Math.sin(-_);return{x:n.x*c-n.z*x,y:n.y,z:n.x*x+n.z*c}});const M=a.map(n=>n.y),u=2e4/(Math.max(...M)-Math.min(...M));let p=a.map(n=>[n.x*u*e,-n.y*u*e,n.z*u*e]);return p=this.applyTemporalSmoothing(p),p}applyTemporalSmoothing(t){if(!this.smoothedLandmarks)return this.smoothedLandmarks=t.map(i=>[...i]),this.smoothedLandmarks;const e=t.map((i,a)=>{const r=this.smoothedLandmarks[a];return[r[0]+this.smoothingFactor*(i[0]-r[0]),r[1]+this.smoothingFactor*(i[1]-r[1]),r[2]+this.smoothingFactor*(i[2]-r[2])]});return this.smoothedLandmarks=e,e}setSmoothingFactor(t){this.smoothingFactor=Math.max(0,Math.min(1,t))}resetSmoothing(){this.smoothedLandmarks=null}start(){if(!this.isInitialized)throw new Error("MediaPipe components are not initialized. Call initializeMediaPipe() first.");return this.camera.start()}stop(){if(!this.isInitialized)throw new Error("MediaPipe components are not initialized. Call initializeMediaPipe() first.");this.camera.stop()}setOnLandmarksCallback(t){this.onLandmarksCallback=t}}var pt=G('<div style=flex-direction:column;align-items:center;justify-content:center;width:300px><h1>Pareidolia</h1><div id=controls><div><!$><!/><svg id=face-svg width=140 height=140></svg></div><h4>Layers</h4><div id=layers><input type=button value=Mask><input type=button value=Basics></div><h4></h4><div>Drag and drop an image to get started.</div><input type=button value=Back><input type=button value=Skip><input type=button value=Next><br><input type=button value="Do it!"><h4>Camera</h4><input type=button value=Start><input type=button value=Stop><br><input type=button value="View Points">');const gt=m=>{let t,e,i;const[a,r]=f(null),[o,d]=f(null),[k,_]=f(!1),[U,M]=f([]),[V,u]=f("basics"),p=1,n=new ut(async s=>{if(s.length>0&&!t){t=s;return}!a()||!s||a().updateActiveTargets(s)&&requestAnimationFrame(()=>{try{a().drawGPU(),console.log("GPU")}catch{a().draw(),console.log("CPU fallback")}})}),c=(s,l)=>{},x=s=>{d(s)},H=()=>{a()&&(a()?.destroy(),r(null));const s=new Map,l=new N(s,t,o(),p);r(l)},Z=()=>{};return S(dt,{controls:{render:s=>(()=>{var l=O(pt),P=l.firstChild,j=P.nextSibling,v=j.firstChild,q=v.firstChild,[C,W]=nt(q.nextSibling),g=C.nextSibling,J=v.nextSibling,z=J.nextSibling,B=z.firstChild,K=B.nextSibling,L=z.nextSibling,Q=L.nextSibling,T=Q.nextSibling,w=T.nextSibling,F=w.nextSibling,tt=F.nextSibling,E=tt.nextSibling,et=E.nextSibling,I=et.nextSibling,A=I.nextSibling,it=A.nextSibling,at=it.nextSibling;h(l,"display","flex"),h(v,"position","relative"),$(v,S(st,{id:"face",ref(y){var X=e;typeof X=="function"?X(y):e=y},width:140,height:140}),C,W);var Y=i;return typeof Y=="function"?ot(Y,g):i=g,h(g,"position","absolute"),h(g,"top","50%"),h(g,"left","50%"),h(g,"transform","translate(-50%, -50%)"),B.$$click=()=>u("mask"),K.$$click=()=>u("basics"),$(L,()=>s.featureName),b(T,"click",s.onBack),b(w,"click",s.onSkip),b(F,"click",s.onNext),E.$$click=H,I.$$click=()=>{n.start().catch(y=>{console.error("Failed to start camera:",y)})},A.$$click=()=>{n.stop()},at.$$click=Z,rt(),l})()},tpsConfig:{create:(s,l)=>{const P=new N(s,t,l,p);return r(P),P},update:(s,l)=>{s.updateActiveTargets(l)},destroy:s=>{s.destroy(),r(null)}},onFeatureComplete:c,onImageProcessed:x})};lt(["click"]);var ft=G("<div>");const vt=()=>(new ct,(()=>{var m=O(ft);return h(m,"width","100vw"),h(m,"height","100vh"),$(m,S(ht,{get children(){return S(gt,{})}})),m})());export{vt as default};

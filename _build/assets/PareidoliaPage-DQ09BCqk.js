import{a as J,N as R,g as _,t as L,d as ot,s as d,i as I,c as K,o as bt,F as Bt,h as dt,e as $t,r as V,p as St,n as ft,m as C,b as kt,f as ct,j as at,k as mt,E as ht,u as rt,C as Mt}from"./client-jDQGuH0I.js";import{s as st,T as q,G as Ct,f as b}from"./GPU-DfCXmufw.js";var Et=L("<div style=flex-direction:column;align-items:center;justify-content:center;width:300px><h1 class=pixelated-text></h1><div id=controls class=pixelated-border><h4>Expression</h4><!$><!/><!$><!/><input type=button value=Reset><!$><!/>"),Tt=L("<div id=emotion-sliders style=align-items:center><input type=range min=-100 max=100><span>");const At=c=>{const[t,a]=J(R);return(()=>{var e=_(Et),l=e.firstChild,r=l.nextSibling,f=r.firstChild,i=f.nextSibling,[m,k]=ot(i.nextSibling),y=m.nextSibling,[D,U]=ot(y.nextSibling),N=D.nextSibling,P=N.nextSibling,[$,Y]=ot(P.nextSibling);return d(e,"display","flex"),I(l,()=>c.title),I(r,K(Bt,{id:"face",width:140,height:140,get expressionModel(){return new bt(c.emotionModel)},emotionLevels:t}),m,k),I(r,K(St,{get each(){return Object.keys(R)},children:X=>(()=>{var H=_(Tt),W=H.firstChild,Q=W.nextSibling;return d(H,"display","flex"),d(H,"gap","10px"),W.$$input=p=>{const j={...t(),[X]:parseInt(p.target.value)};a(j),c.callback(j)},I(Q,()=>String(X)),dt(()=>$t(W,"value",t()[X])),V(),H})()}),D,U),N.$$click=()=>{a(R),document.querySelectorAll("#emotion-sliders input[type='range']").forEach(X=>{X.value="0"}),c.callback(R)},I(r,()=>c.children,$,Y),V(),e})()};ft(["click","input"]);const gt=c=>({minX:Math.floor(Math.min(...c.map(t=>t[0]))),maxX:Math.ceil(Math.max(...c.map(t=>t[0]))),minY:Math.floor(Math.min(...c.map(t=>t[1]))),maxY:Math.ceil(Math.max(...c.map(t=>t[1]))),minZ:Math.floor(Math.min(...c.map(t=>t[2]))),maxZ:Math.ceil(Math.max(...c.map(t=>t[2])))}),pt=(c,t,a)=>(t[0]-c[0])*(a[1]-c[1])-(t[1]-c[1])*(a[0]-c[0]),ut=(c,t)=>Math.hypot(t[0]-c[0],t[1]-c[1]),Dt=c=>{if(c.length<3)return c;let t=0;for(let r=1;r<c.length;r++)(c[r][1]<c[t][1]||c[r][1]===c[t][1]&&c[r][0]<c[t][0])&&(t=r);const a=c[t],e=c.filter((r,f)=>f!==t).sort((r,f)=>{const i=Math.atan2(r[1]-a[1],r[0]-a[0]),m=Math.atan2(f[1]-a[1],f[0]-a[0]);return i!==m?i-m:ut(a,r)-ut(a,f)}),l=[a];for(const r of e){for(;l.length>1&&pt(l[l.length-2],l[l.length-1],r)<=0;)l.pop();l.push(r)}return l},_t=(c,t)=>{if(t.length<3)return!1;for(let a=0;a<t.length;a++){const e=t[a],l=t[(a+1)%t.length];if(pt(e,l,c)<0)return!1}return!0};class Lt{imageLandmarks;emotionModel;emotionTransforms;baseTransform;imagePoints;modelPoints;allPoints;imageBBox;modelBBox;nilpotentTPS;baseTPS;emotionTPS;baseEmotionLevels;canvas;ctx;hull;silhouetteHull;imageSilhouette;mask;gpu;blurMask;offscreenCanvas;offscreenCtx;processingScale;imageData;skipLandmarks;constructor(t,a,e){this.emotionModel=e,this.imageLandmarks=t,this.processingScale=1,this.skipLandmarks=4,this.imagePoints=[],this.modelPoints=[],this.silhouetteHull=[];for(let i=0;i<st.path.length;i++)this.silhouetteHull.push([C[st.path[i]*3],-C[st.path[i]*3+1],C[st.path[i]*3+2]]);this.baseEmotionLevels={...R,...a};const l=e.calculateCompositeEmotion(this.baseEmotionLevels);for(const[i,m]of t){this.imagePoints.push([...m]);const k=parseInt(i);this.modelPoints.push([l[k*3]+C[k*3],l[k*3+1]-C[k*3+1],l[k*3+2]+C[k*3+2]])}this.allPoints=[];for(let i=0;i<C.length;i+=3*this.skipLandmarks)this.allPoints.push([l[i]+C[i],l[i+1]-C[i+1],l[i+2]+C[i+2]]);this.emotionTransforms=[],this.emotionModel=e,this.baseTPS=new q(this.modelPoints,this.imagePoints),this.emotionTPS=new q(this.allPoints,this.allPoints),this.nilpotentTPS=new q(this.imagePoints,this.imagePoints),this.imageSilhouette=[];for(let i=0;i<this.silhouetteHull.length;i++)this.imageSilhouette.push(this.baseTPS.forward(this.silhouetteHull[i]));console.log("imageSilhouette",this.imageSilhouette,this.silhouetteHull),this.imageBBox=gt(this.imageSilhouette),this.modelBBox=gt(this.silhouetteHull),this.baseTransform=this.precomputeTransformationMaps(this.nilpotentTPS),Object.keys(R).forEach(i=>{this.emotionTransforms[i]=this.getEmotionTransform({[i]:100})}),console.log("emotionTransforms",this.emotionTransforms),this.canvas=document.createElement("canvas"),this.canvas.width=this.imageBBox.maxX-this.imageBBox.minX,this.canvas.height=this.imageBBox.maxY-this.imageBBox.minY,this.canvas.style.position="absolute",this.canvas.style.top=this.imageBBox.minY+"px",this.canvas.style.left=this.imageBBox.minX+"px",this.canvas.style.pointerEvents="none",this.canvas.style.background="transparent",this.ctx=this.canvas.getContext("2d"),this.offscreenCanvas=new OffscreenCanvas(this.canvas.width/this.processingScale,this.canvas.height/this.processingScale),this.offscreenCtx=this.offscreenCanvas.getContext("2d"),this.offscreenCtx.fillRect(0,0,this.canvas.width/this.processingScale,this.canvas.height/this.processingScale),this.ctx.fillStyle="transparent",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.hull=Dt(this.imageSilhouette),this.mask=new Uint8ClampedArray(this.canvas.width*this.canvas.height);for(let i=0;i<this.canvas.height;i++)for(let m=0;m<this.canvas.width;m++)this.mask[i*this.canvas.width+m]=_t([m+this.imageBBox.minX,i+this.imageBBox.minY],this.hull)?255:0;let r=new Uint8ClampedArray([...this.mask]);this.blurMask=new Uint8Array(this.canvas.width*this.canvas.height);const f=20;for(let i=0;i<f;i++){for(let m=0;m<this.canvas.height;m++)for(let k=0;k<this.canvas.width;k++){this.blurMask[m*this.canvas.width+k]=0;for(let y=-1;y<=1;y++)for(let D=-1;D<=1;D++){const U=m+y,N=k+D;U<0||U>=this.canvas.height||N<0||N>=this.canvas.width||(this.blurMask[m*this.canvas.width+k]+=r[U*this.canvas.width+N]*Math.pow(.5,2+Math.abs(y)+Math.abs(D)))}}r=new Uint8ClampedArray([...this.blurMask])}return this.gpu=new Ct,this}async initializeGPU(t){this.imageData=t;try{await this.gpu.initialize(),console.log("GPU initialized successfully for ImageTPS"),this.gpu.createBuffers({baseNumPoints:this.imagePoints.length,distortNumPoints:this.allPoints.length,imageWidth:this.imageData.width,imageHeight:this.imageData.height,faceMinY:this.imageBBox.minY,faceMinX:this.imageBBox.minX,faceWidth:this.imageBBox.maxX-this.imageBBox.minX,faceHeight:this.imageBBox.maxY-this.imageBBox.minY}),this.gpu.updateBuffer(this.gpu.meshPointsBuffer,new Float32Array(this.modelPoints.map(e=>e.slice(0,2)).flat())),this.gpu.updateBuffer(this.gpu.imagePointsBuffer,new Float32Array(this.imagePoints.map(e=>e.slice(0,2)).flat())),this.gpu.updateBuffer(this.gpu.distortPointsBuffer,new Float32Array(this.allPoints.map(e=>e.slice(0,2)).flat())),this.gpu.updateBuffer(this.gpu.modelPointsBuffer,new Float32Array(this.modelPoints.map(e=>e.slice(0,2)).flat())),this.gpu.updateBaseCoeffs(this.baseTPS.inverseParameters.Xc,this.baseTPS.inverseParameters.Yc,this.baseTPS.forwardParameters.Xc,this.baseTPS.forwardParameters.Yc);const a=new Uint32Array(this.imageData.data.length/4);for(let e=0;e<this.imageData.data.length;e+=4)a[e/4]=this.imageData.data[e+3]<<24|this.imageData.data[e+2]<<16|this.imageData.data[e+1]<<8|this.imageData.data[e];this.gpu.updateUintBuffer(this.gpu.imageDataBuffer,a),this.gpu.updateFaceDataWithBlurMask(this.blurMask),this.gpu.updateUniforms({baseNumPoints:this.imagePoints.length,distortNumPoints:this.allPoints.length,imageWidth:this.imageData.width,imageHeight:this.imageData.height,faceMinY:this.imageBBox.minY,faceMinX:this.imageBBox.minX,faceWidth:this.imageBBox.maxX-this.imageBBox.minX,faceHeight:this.imageBBox.maxY-this.imageBBox.minY}),console.log("GPU buffers initialized successfully for ImageTPS")}catch(a){console.error("Failed to initialize GPU for ImageTPS:",a)}}getEmotionTransform(t){let a=[];const e=this.emotionModel.calculateCompositeEmotion(t);for(const[r,f]of this.imageLandmarks){const i=parseInt(r);a.push([e[i*3]+C[i*3],e[i*3+1]-C[i*3+1],e[i*3+2]+C[i*3+2]])}const l=new q(this.modelPoints,a);return this.precomputeTransformationMaps(l)}precomputeTransformationMaps(t){const a=new Map;for(let e=this.imageBBox.minY;e<this.imageBBox.maxY;e++)for(let l=this.imageBBox.minX;l<this.imageBBox.maxX;l++){const r=`${l},${e}`,f=this.baseTPS.forward(t.forward(this.baseTPS.inverse([l,e,0])));a.set(r,f)}return a}transformXY(t,a,e){let l=a*100,r=e*100,f=100;for(const i in t){if(t[i]==0)continue;const m=this.emotionTransforms[i].get(`${a},${e}`);l+=t[i]*m[0],r+=t[i]*m[1],f+=t[i]}return[l/f,r/f]}async transformGPU(t){if(!this.gpu.initialized)return console.log("GPU not ready for ImageTPS, falling back to CPU"),null;try{const e=[],l=this.emotionModel.calculateCompositeEmotion(t);for(var a=0;a<l.length;a+=3*this.skipLandmarks)e.push([l[a]+C[a],l[a+1]-C[a+1],l[a+2]+C[a+2]]);this.emotionTPS=new q(e,this.allPoints),this.gpu.updateCombinedCoeffs(this.gpu.model2distortCoeffsBuffer,this.emotionTPS.inverseParameters.Xc,this.emotionTPS.inverseParameters.Yc);const r=this.imageBBox.maxX-this.imageBBox.minX,f=this.imageBBox.maxY-this.imageBBox.minY;this.gpu.updateUniforms({baseNumPoints:this.imagePoints.length,distortNumPoints:this.allPoints.length,imageWidth:this.imageData.width,imageHeight:this.imageData.height,faceMinY:this.imageBBox.minY,faceMinX:this.imageBBox.minX,faceWidth:r,faceHeight:f}),await this.gpu.execute(r,f);const i=await this.gpu.readBuffer(this.gpu.faceDataBuffer,r*f*4),m=new ImageData(i,r,f);return this.gpu.updateFaceDataWithBlurMask(this.blurMask),m}catch(e){return console.error("Error executing GPU transformation for ImageTPS:",e),null}}async drawGPU(t,a){const e=await this.transformGPU(t);e?(this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.offscreenCtx.putImageData(e,0,0),this.ctx.drawImage(this.offscreenCanvas,0,0,this.canvas.width,this.canvas.height),console.log("GPU rendering")):(this.drawCPU(t,a),console.log("CPU fallback"))}drawCPU(t,a){const e={...t};for(var l in this.baseEmotionLevels)e[l]-=this.baseEmotionLevels[l];const r=new Uint8ClampedArray(this.canvas.width*this.canvas.height*4).fill(0),f=a.width;for(var i=0;i<this.canvas.height;i++)for(var m=0;m<this.canvas.width;m++){if(this.mask[i*this.canvas.width+m]==0)continue;const k=this.transformXY(e,m+this.imageBBox.minX,i+this.imageBBox.minY),y=(i*this.canvas.width+m)*4,D=(Math.round(k[1])*f+Math.round(k[0]))*4;D>=0&&D<a.data.length-3&&(r[y]=a.data[D],r[y+1]=a.data[D+1],r[y+2]=a.data[D+2],r[y+3]=a.data[D+3])}this.ctx.putImageData(new ImageData(r,this.canvas.width,this.canvas.height),0,0)}destroy(){this.gpu&&this.gpu.destroy(),this.canvas&&this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas)}}var Ut=L("<h4>"),Xt=L("<div>"),Yt=L("<input type=button value=Back>"),It=L("<input type=button value=Skip>"),Nt=L("<input type=button value=Next>"),Ht=L("<br>"),jt=L('<input type=button value="Do it!">'),Gt=L('<div id=pareidolia style=flex-direction:row;align-items:center;justify-content:center><div style="flex-direction:column;align-items:center;justify-content:center;transform-origin:center center;flex-grow:3;flex-shrink:0"><div style=font-size:16px;pointer-events:none;z-index:1000>Drop an image here</div><canvas id=source></canvas><svg id=landmarks xmlns=http://www.w3.org/2000/svg style=stroke:blue;fill:rgba(255,255,255,0.4)></svg></div><!$><!/>');const nt=0,Ft=c=>{let t,a,e,l;const{emotionModel:r}=c,[f,i]=J(!1),[m,k]=J({width:600,height:600}),[y,D]=J(1),[U,N]=J("Upload an Image"),P={};let $=0,Y,X=R,H=R,W=!1;const Q=h=>{const o=m().width,n=m().height,g=h.filter((v,E)=>E%3===0),x=h.filter((v,E)=>E%3===1),M=Math.min(...g),w=Math.min(...x),u=Math.max(...g),S=Math.max(...x),B=(o-2*nt)/(u-M),A=(n-2*nt)/(S-w);return h.map((v,E)=>E%3===0?(v-M)*B+nt:E%3===1?n-((v-w)*A+nt):v)};Q(mt.vertices);let p=null,tt=()=>{};const j=()=>{tt();const h=Object.keys(b)[$];N(h)},vt=async()=>{tt(),p&&(p.destroy(),p.canvas.remove()),H={...X};const h=new Map;for(const n in P)if(!(b[n].path.length==0||P[n].length==0))if(P[n].length==1)h.set(b[n].path[0],[P[n][0].x,P[n][0].y,0]);else if(P[n].length==2)h.set(b[n].path[0],[P[n][0].x,P[n][0].y,0]),h.set(b[n].path[1],[P[n][1].x,P[n][1].y,0]);else{const g=xt(P[n],n);for(var o=0;o<b[n].path.length;o++)h.set(b[n].path[o],g[o])}p=new Lt(h,X,new ht),p.canvas.style.position="absolute",p.canvas.style.top="50%",p.canvas.style.left="50%",p.canvas.style.transform=`translate(${-t.getBoundingClientRect().width/(2*y())}px, ${-t.getBoundingClientRect().height/(2*y())}px) translate(${p.imageBBox.minX}px, ${p.imageBBox.minY}px)`,p.canvas.style.pointerEvents="none",t.after(p.canvas),await p.initializeGPU(Y)},xt=(h,o)=>{const n=new ht().calculateCompositeEmotion(X),g=b[o].path.map((v,E)=>{const T=v*3;return[n[T]+C[T],n[T+1]-C[T+1],n[T+2]+C[T+2]]});b[o].closed&&(h.push(h[0]),g.push(g[0]));const x=document.createElementNS("http://www.w3.org/2000/svg","path");x.setAttribute("d",`M ${g.map((v,E)=>`${v[0]} ${v[1]}`).join(" L ")}`);const M=document.createElementNS("http://www.w3.org/2000/svg","path");M.setAttribute("d",`M ${h.map((v,E)=>`${v.x} ${v.y}`).join(" L ")}`);const w=M.getTotalLength(),u=x.getTotalLength(),S=w/u;let B=M.getPointAtLength(0);const A=[[B.x,B.y,0]];let s=0;for(let v=0;v<g.length-1;v++){const E=g[v],T=g[v+1];s+=Math.hypot(E[0]-T[0],E[1]-T[1]),B=M.getPointAtLength(s*S),A.push([B.x,B.y,0])}return console.log(A),A},wt=(h,o)=>{const g=window.innerHeight*.8;return Math.min(g/o,1)},yt=h=>{h.preventDefault(),h.stopPropagation()},Pt=h=>{h.preventDefault(),h.stopPropagation();const o=h.dataTransfer?.files;if(!o||o.length===0)return;const n=o[0];if(!n.type.startsWith("image/")){alert("Please drop an image file");return}const g=new FileReader;g.onload=x=>{const M=new Image;M.onload=()=>{const w=M.width,u=M.height;k({width:w,height:u});const S=wt(w,u);D(S),t&&(t.width=w,t.height=u,a=t.getContext("2d"),a?.drawImage(M,0,0)),e&&(e.setAttribute("width",w.toString()),e.setAttribute("height",u.toString())),Y=a.getImageData(0,0,w,u),i(!0),Q(mt.vertices),j()},M.src=x.target?.result},g.readAsDataURL(n)};return kt(()=>{if(!t||!e||(a=t.getContext("2d"),!f()))return;let h=!1,o={x:0,y:0};const n=document.createElementNS("http://www.w3.org/2000/svg","circle");n.setAttribute("cx",o.x.toString()),n.setAttribute("cy",o.y.toString()),n.setAttribute("r",(5/y()).toString()),n.style.stroke="red",n.style.fill="red";const g=document.createElementNS("http://www.w3.org/2000/svg","line");g.setAttribute("x1",o.x.toString()),g.setAttribute("y1",o.y.toString()),g.setAttribute("x2",o.x.toString()),g.setAttribute("y2",o.y.toString()),g.style.stroke="red",g.style.fill="red";const x=document.createElementNS("http://www.w3.org/2000/svg","path");x.setAttribute("d",`M ${o.x} ${o.y} L ${o.x} ${o.y}`),x.style.stroke="red",x.style.fill="rgba(255,0,0,0.2)";const M=w=>{const u=e.getBoundingClientRect(),S=(w.clientX-u.left)/y(),B=(w.clientY-u.top)/y();return{x:S,y:B}};tt=()=>{n.remove(),g.remove(),x.remove()},e.onmousedown=w=>{if($==null)return;const u=Object.keys(b)[$];w.preventDefault(),w.stopPropagation();const{x:S,y:B}=M(w);h=!0,o={x:S,y:B},P[u]=[],b[u].path.length==1?(n.setAttribute("cx",S.toString()),n.setAttribute("cy",B.toString()),e.appendChild(n)):b[u].path.length==2?(P[u].push(o),g.setAttribute("x1",o.x.toString()),g.setAttribute("y1",o.y.toString()),g.setAttribute("x2",o.x.toString()),g.setAttribute("y2",o.y.toString()),e.appendChild(g)):(P[u].push(o),x.setAttribute("d","M "+P[u].map((A,s)=>`${A.x} ${A.y}`).join(" L ")),e.appendChild(x))},e.onmousemove=w=>{if($==null)return;const u=Object.keys(b)[$];if(w.preventDefault(),w.stopPropagation(),h){const{x:S,y:B}=M(w);b[u].path.length==1?(n.setAttribute("cx",S.toString()),n.setAttribute("cy",B.toString())):b[u].path.length==2?(g.setAttribute("x2",S.toString()),g.setAttribute("y2",B.toString())):(P[u].push({x:S,y:B}),x.setAttribute("d","M "+P[u].map((A,s)=>`${A.x} ${A.y}`).join(" L ")))}},e.onmouseup=w=>{if($==null)return;const u=Object.keys(b)[$];w.preventDefault(),w.stopPropagation(),h=!1;const{x:S,y:B}=M(w);b[u].path.length==1?P[u].push(o):b[u].path.length==2?P[u].push({x:S,y:B}):(P[u].push({x:S,y:B}),P[u].push({x:o.x,y:o.y}),x.setAttribute("d","M "+P[u].map((A,s)=>`${A.x} ${A.y}`).join(" L "))),$++,$=Math.min($,Object.keys(b).length),j()}}),(()=>{var h=_(Gt),o=h.firstChild,n=o.firstChild,g=n.nextSibling,x=g.nextSibling,M=o.nextSibling,[w,u]=ot(M.nextSibling);h.addEventListener("drop",Pt),h.addEventListener("dragover",yt);var S=l;typeof S=="function"?rt(S,h):l=h,d(h,"position","relative"),d(h,"display","flex"),d(h,"border","2px dashed #ccc"),d(h,"padding","10px"),d(h,"cursor","pointer"),d(h,"width","100vw"),d(h,"height","100vh"),d(h,"background","rgba(255,0,0,.1)"),d(o,"position","relative"),d(o,"display","flex"),d(n,"position","absolute"),d(n,"top","50%"),d(n,"left","50%"),d(n,"transform","translate(-50%, -50%)"),d(n,"color","#999"),d(n,"background","white");var B=t;typeof B=="function"?rt(B,g):t=g,d(g,"display","block");var A=e;return typeof A=="function"?rt(A,x):e=x,d(x,"position","absolute"),d(x,"top","50%"),d(x,"left","50%"),d(x,"transform","translate(-50%, -50%)"),d(x,"filter","invert(1)"),I(h,K(At,{title:"Pareidolia",emotionModel:r,callback:async s=>{if(W||!p)return;X=s;const v={...X};for(var E in H)v[E]-=H[E];W=!0;try{await p.drawGPU(v,Y)}catch(et){console.error("GPU rendering failed, using CPU fallback:",et);const F=new Uint8ClampedArray(p.canvas.width*p.canvas.height*4).fill(0),it=m().width;for(var T=0;T<p.canvas.height;T++)for(var G=0;G<p.canvas.width;G++){if(p.mask[T*p.canvas.width+G]==0)continue;const Z=p.transformXY(v,G+p.imageBBox.minX,T+p.imageBBox.minY),z=(T*p.canvas.width+G)*4,O=(Math.round(Z[1])*it+Math.round(Z[0]))*4;F[z]=Y.data[O],F[z+1]=Y.data[O+1],F[z+2]=Y.data[O+2],F[z+3]=Y.data[O+3]}p.ctx.putImageData(new ImageData(F,p.canvas.width,p.canvas.height),0,0)}finally{W=!1}},get children(){return[(()=>{var s=_(Ut);return I(s,(()=>{var v=ct(()=>U()in b);return()=>v()?b[U()].name:"Upload an Image"})()),s})(),(()=>{var s=_(Xt);return I(s,(()=>{var v=ct(()=>U()in b);return()=>v()?b[U()].description:"Drag and drop an image to get started."})()),s})(),(()=>{var s=_(Yt);return s.$$click=()=>{$=Math.max(0,$-1),j()},V(),s})(),(()=>{var s=_(It);return s.$$click=()=>{P[U()]=[],$++,$>=Object.keys(b).length&&($=0),j()},V(),s})(),(()=>{var s=_(Nt);return s.$$click=()=>{$++,$>=Object.keys(b).length&&($=0),j()},V(),s})(),_(Ht),(()=>{var s=_(jt);return s.$$click=()=>{vt()},V(),s})()]}}),w,u),dt(s=>{var v=`scale(${y()})`,E=f()?m().width*y()+"px":"auto",T=f()?m().height*y()+"px":"auto",G=f()?"none":"block",et=m().width,F=m().height,it=f()?`${-.5/y()}em ${.5/y()}em 0 rgba(0,0,0,.5), ${-1/y()}em ${1/y()}em 0 gray`:"none",Z=m().width,z=m().height,O=f()?"auto":"none",lt=`${5/y()}px`;return v!==s.e&&d(o,"transform",s.e=v),E!==s.t&&d(o,"width",s.t=E),T!==s.a&&d(o,"height",s.a=T),G!==s.o&&d(n,"display",s.o=G),et!==s.i&&at(g,"width",s.i=et),F!==s.n&&at(g,"height",s.n=F),it!==s.s&&d(g,"box-shadow",s.s=it),Z!==s.h&&at(x,"width",s.h=Z),z!==s.r&&at(x,"height",s.r=z),O!==s.d&&d(x,"pointer-events",s.d=O),lt!==s.l&&d(x,"stroke-width",s.l=lt),s},{e:void 0,t:void 0,a:void 0,o:void 0,i:void 0,n:void 0,s:void 0,h:void 0,r:void 0,d:void 0,l:void 0}),h})()};ft(["click"]);var Rt=L("<div>"),Wt=L('<div class="flex items-center justify-center h-full"><div class=text-center><p class=text-lg>Loading pareidolia...');const Vt=()=>{const c=new ht;return(()=>{var t=_(Rt);return d(t,"width","100vw"),d(t,"height","100vh"),I(t,K(Mt,{get fallback(){return _(Wt)},get children(){return K(Ft,{emotionModel:c})}})),t})()};export{Vt as default};
